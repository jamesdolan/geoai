
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A Python package for using Artificial Intelligence (AI) with geospatial data">
      
      
        <meta name="author" content="opengeos">
      
      
        <link rel="canonical" href="https://geoai.gishub.org/extract/">
      
      
        <link rel="prev" href="../download/">
      
      
        <link rel="next" href="../hf/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.7">
    
    
      
        <title>extract module - geoai</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:300,300i,400,400i,700,700i%7CRegular:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Google Sans";--md-code-font:"Regular"}</style>
      
    
    
      <link rel="stylesheet" href="../css/timeago.css">
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#extract-module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="geoai" class="md-header__button md-logo" aria-label="geoai" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            geoai
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              extract module
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/opengeos/geoai" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="geoai" class="md-nav__button md-logo" aria-label="geoai" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    geoai
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/opengeos/geoai" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/opengeos/geoai/releases" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/opengeos/geoai/issues" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Report Issues
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/download_data/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Download data
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/view_metadata/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    View metadata
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/image_chips/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Image chips
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/building_footprints_usa/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Building footprints usa
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/building_footprints_africa/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Building footprints africa
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/building_footprints_china/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Building footprints china
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/building_regularization/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Building regularization
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/geometric_properties/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Geometric properties
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/car_detection/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Car detection
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/ship_detection/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ship detection
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/solar_panel_detection/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Solar panel detection
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/text_prompt_segmentation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Text prompt segmentation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/parking_spot_detection/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Parking spot detection
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/data_visualization/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Data visualization
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/dataviz/raster_viz/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Raster viz
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/dataviz/vector_viz/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vector viz
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/dataviz/lidar_viz/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lidar viz
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geoai/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    geoai module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../download/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    download module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    extract module
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    extract module
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#geoai.extract" class="md-nav__link">
    <span class="md-ellipsis">
      geoai.extract
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor" class="md-nav__link">
    <span class="md-ellipsis">
      BuildingFootprintExtractor
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BuildingFootprintExtractor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor.regularize_buildings" class="md-nav__link">
    <span class="md-ellipsis">
      regularize_buildings()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.CarDetector" class="md-nav__link">
    <span class="md-ellipsis">
      CarDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CarDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CarDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset" class="md-nav__link">
    <span class="md-ellipsis">
      CustomDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CustomDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__len__" class="md-nav__link">
    <span class="md-ellipsis">
      __len__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ObjectDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ObjectDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.download_model_from_hf" class="md-nav__link">
    <span class="md-ellipsis">
      download_model_from_hf()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.filter_edge_objects" class="md-nav__link">
    <span class="md-ellipsis">
      filter_edge_objects()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.filter_overlapping_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      filter_overlapping_polygons()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.generate_masks" class="md-nav__link">
    <span class="md-ellipsis">
      generate_masks()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.initialize_model" class="md-nav__link">
    <span class="md-ellipsis">
      initialize_model()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.load_weights" class="md-nav__link">
    <span class="md-ellipsis">
      load_weights()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.mask_to_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      mask_to_polygons()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.masks_to_vector" class="md-nav__link">
    <span class="md-ellipsis">
      masks_to_vector()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.process_raster" class="md-nav__link">
    <span class="md-ellipsis">
      process_raster()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.regularize_objects" class="md-nav__link">
    <span class="md-ellipsis">
      regularize_objects()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.save_masks_as_geotiff" class="md-nav__link">
    <span class="md-ellipsis">
      save_masks_as_geotiff()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.vectorize_masks" class="md-nav__link">
    <span class="md-ellipsis">
      vectorize_masks()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.visualize_results" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_results()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ParkingSplotDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ParkingSplotDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParkingSplotDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ParkingSplotDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ShipDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ShipDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ShipDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ShipDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.SolarPanelDetector" class="md-nav__link">
    <span class="md-ellipsis">
      SolarPanelDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SolarPanelDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.SolarPanelDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../hf/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    hf module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../segmentation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    segmentation module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    utils module
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#geoai.extract" class="md-nav__link">
    <span class="md-ellipsis">
      geoai.extract
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor" class="md-nav__link">
    <span class="md-ellipsis">
      BuildingFootprintExtractor
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BuildingFootprintExtractor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.BuildingFootprintExtractor.regularize_buildings" class="md-nav__link">
    <span class="md-ellipsis">
      regularize_buildings()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.CarDetector" class="md-nav__link">
    <span class="md-ellipsis">
      CarDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CarDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CarDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset" class="md-nav__link">
    <span class="md-ellipsis">
      CustomDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CustomDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.CustomDataset.__len__" class="md-nav__link">
    <span class="md-ellipsis">
      __len__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ObjectDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ObjectDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.download_model_from_hf" class="md-nav__link">
    <span class="md-ellipsis">
      download_model_from_hf()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.filter_edge_objects" class="md-nav__link">
    <span class="md-ellipsis">
      filter_edge_objects()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.filter_overlapping_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      filter_overlapping_polygons()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.generate_masks" class="md-nav__link">
    <span class="md-ellipsis">
      generate_masks()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.initialize_model" class="md-nav__link">
    <span class="md-ellipsis">
      initialize_model()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.load_weights" class="md-nav__link">
    <span class="md-ellipsis">
      load_weights()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.mask_to_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      mask_to_polygons()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.masks_to_vector" class="md-nav__link">
    <span class="md-ellipsis">
      masks_to_vector()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.process_raster" class="md-nav__link">
    <span class="md-ellipsis">
      process_raster()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.regularize_objects" class="md-nav__link">
    <span class="md-ellipsis">
      regularize_objects()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.save_masks_as_geotiff" class="md-nav__link">
    <span class="md-ellipsis">
      save_masks_as_geotiff()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.vectorize_masks" class="md-nav__link">
    <span class="md-ellipsis">
      vectorize_masks()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ObjectDetector.visualize_results" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_results()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ParkingSplotDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ParkingSplotDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParkingSplotDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ParkingSplotDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.ShipDetector" class="md-nav__link">
    <span class="md-ellipsis">
      ShipDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ShipDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.ShipDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#geoai.extract.SolarPanelDetector" class="md-nav__link">
    <span class="md-ellipsis">
      SolarPanelDetector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SolarPanelDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#geoai.extract.SolarPanelDetector.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  


  
  


<h1 id="extract-module">extract module<a class="headerlink" href="#extract-module" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="geoai.extract"></a>
    <div class="doc doc-contents first">

      <p>This module provides a dataset class for object extraction from raster data</p>



  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.BuildingFootprintExtractor" class="doc doc-heading">
        <code>
BuildingFootprintExtractor            (<a class="autorefs autorefs-internal" title="geoai.extract.ObjectDetector" href="#geoai.extract.ObjectDetector">ObjectDetector</a>)
        </code>



<a href="#geoai.extract.BuildingFootprintExtractor" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Building footprint extraction using a pre-trained Mask R-CNN model.</p>
<p>This class extends the
<code>ObjectDetector</code> class with additional methods for building footprint extraction."</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BuildingFootprintExtractor</span><span class="p">(</span><span class="n">ObjectDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Building footprint extraction using a pre-trained Mask R-CNN model.</span>

<span class="sd">    This class extends the</span>
<span class="sd">    `ObjectDetector` class with additional methods for building footprint extraction.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;building_footprints_usa.pth&quot;</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">            model: Custom model to use for inference.</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">regularize_buildings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regularize building footprints to enforce right angles and rectangular shapes.</span>

<span class="sd">        Args:</span>
<span class="sd">            gdf: GeoDataFrame with building footprints</span>
<span class="sd">            min_area: Minimum area in square units to keep a building</span>
<span class="sd">            angle_threshold: Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</span>
<span class="sd">            orthogonality_threshold: Percentage of angles that must be orthogonal for a building to be regularized</span>
<span class="sd">            rectangularity_threshold: Minimum area ratio to building&#39;s oriented bounding box for rectangular simplification</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with regularized building footprints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize_objects</span><span class="p">(</span>
            <span class="n">gdf</span><span class="p">,</span>
            <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">,</span>
            <span class="n">angle_threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">,</span>
            <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="n">orthogonality_threshold</span><span class="p">,</span>
            <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="n">rectangularity_threshold</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.BuildingFootprintExtractor.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s1">&#39;building_footprints_usa.pth&#39;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.BuildingFootprintExtractor.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>&#39;building_footprints_usa.pth&#39;</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Repo ID for loading models from the Hub.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Custom model to use for inference.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;building_footprints_usa.pth&quot;</span><span class="p">,</span>
    <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">        model: Custom model to use for inference.</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.BuildingFootprintExtractor.regularize_buildings" class="doc doc-heading">
<code class="highlight language-python"><span class="n">regularize_buildings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span></code>


<a href="#geoai.extract.BuildingFootprintExtractor.regularize_buildings" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Regularize building footprints to enforce right angles and rectangular shapes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td></td>
        <td><p>GeoDataFrame with building footprints</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>min_area</code></td>
        <td></td>
        <td><p>Minimum area in square units to keep a building</p></td>
        <td><code>10</code></td>
      </tr>
      <tr>
        <td><code>angle_threshold</code></td>
        <td></td>
        <td><p>Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</p></td>
        <td><code>15</code></td>
      </tr>
      <tr>
        <td><code>orthogonality_threshold</code></td>
        <td></td>
        <td><p>Percentage of angles that must be orthogonal for a building to be regularized</p></td>
        <td><code>0.3</code></td>
      </tr>
      <tr>
        <td><code>rectangularity_threshold</code></td>
        <td></td>
        <td><p>Minimum area ratio to building's oriented bounding box for rectangular simplification</p></td>
        <td><code>0.7</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with regularized building footprints</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">regularize_buildings</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regularize building footprints to enforce right angles and rectangular shapes.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf: GeoDataFrame with building footprints</span>
<span class="sd">        min_area: Minimum area in square units to keep a building</span>
<span class="sd">        angle_threshold: Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</span>
<span class="sd">        orthogonality_threshold: Percentage of angles that must be orthogonal for a building to be regularized</span>
<span class="sd">        rectangularity_threshold: Minimum area ratio to building&#39;s oriented bounding box for rectangular simplification</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with regularized building footprints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize_objects</span><span class="p">(</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">,</span>
        <span class="n">angle_threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">,</span>
        <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="n">orthogonality_threshold</span><span class="p">,</span>
        <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="n">rectangularity_threshold</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.CarDetector" class="doc doc-heading">
        <code>
CarDetector            (<a class="autorefs autorefs-internal" title="geoai.extract.ObjectDetector" href="#geoai.extract.ObjectDetector">ObjectDetector</a>)
        </code>



<a href="#geoai.extract.CarDetector" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Car detection using a pre-trained Mask R-CNN model.</p>
<p>This class extends the <code>ObjectDetector</code> class with additional methods for car detection.</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CarDetector</span><span class="p">(</span><span class="n">ObjectDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Car detection using a pre-trained Mask R-CNN model.</span>

<span class="sd">    This class extends the `ObjectDetector` class with additional methods for car detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;car_detection_usa.pth&quot;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">            model: Custom model to use for inference.</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.CarDetector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s1">&#39;car_detection_usa.pth&#39;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.CarDetector.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>&#39;car_detection_usa.pth&#39;</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Repo ID for loading models from the Hub.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Custom model to use for inference.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;car_detection_usa.pth&quot;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">        model: Custom model to use for inference.</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.CustomDataset" class="doc doc-heading">
        <code>
CustomDataset            (<span title="torchgeo.datasets.geo.NonGeoDataset">NonGeoDataset</span>)
        </code>



<a href="#geoai.extract.CustomDataset" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>A TorchGeo dataset for object extraction with overlapping tiles support.</p>
<p>This dataset class creates overlapping image tiles for object detection,
ensuring complete coverage of the input raster including right and bottom edges.
It inherits from NonGeoDataset to avoid spatial indexing issues.</p>

<p><strong>Attributes:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to the input raster file.</p></td>
      </tr>
      <tr>
        <td><code>chip_size</code></td>
        <td></td>
        <td><p>Size of image chips to extract (height, width).</p></td>
      </tr>
      <tr>
        <td><code>overlap</code></td>
        <td></td>
        <td><p>Amount of overlap between adjacent tiles (0.0-1.0).</p></td>
      </tr>
      <tr>
        <td><code>transforms</code></td>
        <td></td>
        <td><p>Transforms to apply to the image.</p></td>
      </tr>
      <tr>
        <td><code>verbose</code></td>
        <td></td>
        <td><p>Whether to print detailed processing information.</p></td>
      </tr>
      <tr>
        <td><code>stride_x</code></td>
        <td></td>
        <td><p>Horizontal stride between tiles based on overlap.</p></td>
      </tr>
      <tr>
        <td><code>stride_y</code></td>
        <td></td>
        <td><p>Vertical stride between tiles based on overlap.</p></td>
      </tr>
      <tr>
        <td><code>row_starts</code></td>
        <td></td>
        <td><p>Starting Y positions for each row of tiles.</p></td>
      </tr>
      <tr>
        <td><code>col_starts</code></td>
        <td></td>
        <td><p>Starting X positions for each column of tiles.</p></td>
      </tr>
      <tr>
        <td><code>crs</code></td>
        <td></td>
        <td><p>Coordinate reference system of the raster.</p></td>
      </tr>
      <tr>
        <td><code>transform</code></td>
        <td></td>
        <td><p>Affine transform of the raster.</p></td>
      </tr>
      <tr>
        <td><code>height</code></td>
        <td></td>
        <td><p>Height of the raster in pixels.</p></td>
      </tr>
      <tr>
        <td><code>width</code></td>
        <td></td>
        <td><p>Width of the raster in pixels.</p></td>
      </tr>
      <tr>
        <td><code>count</code></td>
        <td></td>
        <td><p>Number of bands in the raster.</p></td>
      </tr>
      <tr>
        <td><code>bounds</code></td>
        <td></td>
        <td><p>Geographic bounds of the raster (west, south, east, north).</p></td>
      </tr>
      <tr>
        <td><code>roi</code></td>
        <td></td>
        <td><p>Shapely box representing the region of interest.</p></td>
      </tr>
      <tr>
        <td><code>rows</code></td>
        <td></td>
        <td><p>Number of rows of tiles.</p></td>
      </tr>
      <tr>
        <td><code>cols</code></td>
        <td></td>
        <td><p>Number of columns of tiles.</p></td>
      </tr>
      <tr>
        <td><code>raster_stats</code></td>
        <td></td>
        <td><p>Statistics of the raster.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CustomDataset</span><span class="p">(</span><span class="n">NonGeoDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A TorchGeo dataset for object extraction with overlapping tiles support.</span>

<span class="sd">    This dataset class creates overlapping image tiles for object detection,</span>
<span class="sd">    ensuring complete coverage of the input raster including right and bottom edges.</span>
<span class="sd">    It inherits from NonGeoDataset to avoid spatial indexing issues.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        raster_path: Path to the input raster file.</span>
<span class="sd">        chip_size: Size of image chips to extract (height, width).</span>
<span class="sd">        overlap: Amount of overlap between adjacent tiles (0.0-1.0).</span>
<span class="sd">        transforms: Transforms to apply to the image.</span>
<span class="sd">        verbose: Whether to print detailed processing information.</span>
<span class="sd">        stride_x: Horizontal stride between tiles based on overlap.</span>
<span class="sd">        stride_y: Vertical stride between tiles based on overlap.</span>
<span class="sd">        row_starts: Starting Y positions for each row of tiles.</span>
<span class="sd">        col_starts: Starting X positions for each column of tiles.</span>
<span class="sd">        crs: Coordinate reference system of the raster.</span>
<span class="sd">        transform: Affine transform of the raster.</span>
<span class="sd">        height: Height of the raster in pixels.</span>
<span class="sd">        width: Width of the raster in pixels.</span>
<span class="sd">        count: Number of bands in the raster.</span>
<span class="sd">        bounds: Geographic bounds of the raster (west, south, east, north).</span>
<span class="sd">        roi: Shapely box representing the region of interest.</span>
<span class="sd">        rows: Number of rows of tiles.</span>
<span class="sd">        cols: Number of columns of tiles.</span>
<span class="sd">        raster_stats: Statistics of the raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raster_path</span><span class="p">,</span>
        <span class="n">chip_size</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span>
        <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the dataset with overlapping tiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            raster_path: Path to the input raster file.</span>
<span class="sd">            chip_size: Size of image chips to extract (height, width). Default is (512, 512).</span>
<span class="sd">            overlap: Amount of overlap between adjacent tiles (0.0-1.0). Default is 0.5 (50%).</span>
<span class="sd">            transforms: Transforms to apply to the image. Default is None.</span>
<span class="sd">            band_indexes: List of band indexes to use. Default is None (use all bands).</span>
<span class="sd">            verbose: Whether to print detailed processing information. Default is False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If overlap is too high resulting in non-positive stride.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Initialize parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span> <span class="o">=</span> <span class="n">raster_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span> <span class="o">=</span> <span class="n">chip_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span> <span class="o">=</span> <span class="n">band_indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Calculate stride based on overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Overlap </span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s2"> is too high, resulting in non-positive stride&quot;</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">count</span>

            <span class="c1"># Define the bounds of the dataset</span>
            <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

            <span class="c1"># Calculate starting positions for each tile</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Normal row starts using stride</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="p">)</span>

            <span class="c1"># Add a special last row that ensures we reach the bottom edge</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the image is smaller than chip size, just start at 0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Normal column starts using stride</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="p">)</span>

            <span class="c1"># Add a special last column that ensures we reach the right edge</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the image is smaller than chip size, just start at 0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Update rows and cols based on actual starting positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dataset initialized with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="si">}</span><span class="s2"> rows and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="si">}</span><span class="s2"> columns of chips&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chip size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Overlap: </span><span class="si">{</span><span class="n">overlap</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% (stride_x=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="si">}</span><span class="s2">, stride_y=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CRS: </span><span class="si">{</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get raster stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">get_raster_stats</span><span class="p">(</span><span class="n">raster_path</span><span class="p">,</span> <span class="n">divide_by</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an image chip from the dataset by index.</span>

<span class="sd">        Retrieves an image tile with the specified overlap pattern, ensuring</span>
<span class="sd">        proper coverage of the entire raster including edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: Index of the chip to retrieve.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary containing:</span>
<span class="sd">                - image: Image tensor.</span>
<span class="sd">                - bbox: Geographic bounding box for the window.</span>
<span class="sd">                - coords: Pixel coordinates as tensor [i, j].</span>
<span class="sd">                - window_size: Window size as tensor [width, height].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert flat index to grid position</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

        <span class="c1"># Get pre-calculated starting positions</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

        <span class="c1"># Read window from raster</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Make sure we don&#39;t read outside the image</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>

            <span class="n">window</span> <span class="o">=</span> <span class="n">Window</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

            <span class="c1"># Handle RGBA or multispectral images - keep only first 3 bands</span>
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image has </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> bands, using first 3 bands only&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># If image has fewer than 3 bands, duplicate the last band to make 3</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Image has </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> bands, duplicating bands to make 3&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">temp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">temp</span>

            <span class="c1"># Handle partial windows at edges by padding</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">temp</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">image</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="c1"># Convert to format expected by model (C,H,W)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

        <span class="c1"># Normalize to [0, 1]</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>

        <span class="c1"># Apply transforms if any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Create geographic bounding box for the window</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span>
            <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="n">bbox</span><span class="p">,</span>
            <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">),</span>  <span class="c1"># Consistent format</span>
            <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
                <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span>
            <span class="p">),</span>  <span class="c1"># Consistent format</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of samples in the dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Total number of tiles in the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.CustomDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.CustomDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Get an image chip from the dataset by index.</p>
<p>Retrieves an image tile with the specified overlap pattern, ensuring
proper coverage of the entire raster including edges.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>idx</code></td>
        <td></td>
        <td><p>Index of the chip to retrieve.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>Dictionary containing:
    - image: Image tensor.
    - bbox: Geographic bounding box for the window.
    - coords: Pixel coordinates as tensor [i, j].
    - window_size: Window size as tensor [width, height].</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an image chip from the dataset by index.</span>

<span class="sd">    Retrieves an image tile with the specified overlap pattern, ensuring</span>
<span class="sd">    proper coverage of the entire raster including edges.</span>

<span class="sd">    Args:</span>
<span class="sd">        idx: Index of the chip to retrieve.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Dictionary containing:</span>
<span class="sd">            - image: Image tensor.</span>
<span class="sd">            - bbox: Geographic bounding box for the window.</span>
<span class="sd">            - coords: Pixel coordinates as tensor [i, j].</span>
<span class="sd">            - window_size: Window size as tensor [width, height].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert flat index to grid position</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

    <span class="c1"># Get pre-calculated starting positions</span>
    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

    <span class="c1"># Read window from raster</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Make sure we don&#39;t read outside the image</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">Window</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

        <span class="c1"># Handle RGBA or multispectral images - keep only first 3 bands</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image has </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> bands, using first 3 bands only&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># If image has fewer than 3 bands, duplicate the last band to make 3</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Image has </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> bands, duplicating bands to make 3&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="c1"># Handle partial windows at edges by padding</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">temp</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">image</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">temp</span>

    <span class="c1"># Convert to format expected by model (C,H,W)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="c1"># Normalize to [0, 1]</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>

    <span class="c1"># Apply transforms if any</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="c1"># Create geographic bounding box for the window</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span>
    <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span>
        <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="n">bbox</span><span class="p">,</span>
        <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">),</span>  <span class="c1"># Consistent format</span>
        <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span>
        <span class="p">),</span>  <span class="c1"># Consistent format</span>
    <span class="p">}</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.CustomDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">chip_size</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.CustomDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the dataset with overlapping tiles.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to the input raster file.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>chip_size</code></td>
        <td></td>
        <td><p>Size of image chips to extract (height, width). Default is (512, 512).</p></td>
        <td><code>(512, 512)</code></td>
      </tr>
      <tr>
        <td><code>overlap</code></td>
        <td></td>
        <td><p>Amount of overlap between adjacent tiles (0.0-1.0). Default is 0.5 (50%).</p></td>
        <td><code>0.5</code></td>
      </tr>
      <tr>
        <td><code>transforms</code></td>
        <td></td>
        <td><p>Transforms to apply to the image. Default is None.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>band_indexes</code></td>
        <td></td>
        <td><p>List of band indexes to use. Default is None (use all bands).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>verbose</code></td>
        <td></td>
        <td><p>Whether to print detailed processing information. Default is False.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If overlap is too high resulting in non-positive stride.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">raster_path</span><span class="p">,</span>
    <span class="n">chip_size</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span>
    <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the dataset with overlapping tiles.</span>

<span class="sd">    Args:</span>
<span class="sd">        raster_path: Path to the input raster file.</span>
<span class="sd">        chip_size: Size of image chips to extract (height, width). Default is (512, 512).</span>
<span class="sd">        overlap: Amount of overlap between adjacent tiles (0.0-1.0). Default is 0.5 (50%).</span>
<span class="sd">        transforms: Transforms to apply to the image. Default is None.</span>
<span class="sd">        band_indexes: List of band indexes to use. Default is None (use all bands).</span>
<span class="sd">        verbose: Whether to print detailed processing information. Default is False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If overlap is too high resulting in non-positive stride.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="c1"># Initialize parameters</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span> <span class="o">=</span> <span class="n">raster_path</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span> <span class="o">=</span> <span class="n">chip_size</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">band_indexes</span> <span class="o">=</span> <span class="n">band_indexes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">warned_about_bands</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Calculate stride based on overlap</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">))</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Overlap </span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s2"> is too high, resulting in non-positive stride&quot;</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">count</span>

        <span class="c1"># Define the bounds of the dataset</span>
        <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># Calculate starting positions for each tile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Normal row starts using stride</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="p">)</span>

        <span class="c1"># Add a special last row that ensures we reach the bottom edge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the image is smaller than chip size, just start at 0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Normal column starts using stride</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="p">)</span>

        <span class="c1"># Add a special last column that ensures we reach the right edge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the image is smaller than chip size, just start at 0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Update rows and cols based on actual starting positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">row_starts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col_starts</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Dataset initialized with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="si">}</span><span class="s2"> rows and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="si">}</span><span class="s2"> columns of chips&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image dimensions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chip size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Overlap: </span><span class="si">{</span><span class="n">overlap</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% (stride_x=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stride_x</span><span class="si">}</span><span class="s2">, stride_y=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stride_y</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CRS: </span><span class="si">{</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Get raster stats</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">get_raster_stats</span><span class="p">(</span><span class="n">raster_path</span><span class="p">,</span> <span class="n">divide_by</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.CustomDataset.__len__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.CustomDataset.__len__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the number of samples in the dataset.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>int</code></td>
      <td><p>Total number of tiles in the dataset.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of samples in the dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: Total number of tiles in the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.ObjectDetector" class="doc doc-heading">
        <code>
ObjectDetector        </code>



<a href="#geoai.extract.ObjectDetector" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Object extraction using Mask R-CNN with TorchGeo.</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ObjectDetector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object extraction using Mask R-CNN with TorchGeo.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Hugging Face repository ID for model download.</span>
<span class="sd">            model: Pre-initialized model object (optional).</span>
<span class="sd">            num_classes: Number of classes for detection (default: 2).</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set device</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Default parameters for object detection - these can be overridden in process_raster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>  <span class="c1"># Size of image chips for processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.25</span>  <span class="c1"># Default overlap between tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Default confidence threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># IoU threshold for non-maximum suppression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Minimum area in pixels to keep an object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Maximum area in pixels to keep an object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Threshold for mask binarization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Tolerance for polygon simplification</span>

        <span class="c1"># Initialize model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">)</span>

        <span class="c1"># Download model if needed</span>
        <span class="k">if</span> <span class="n">model_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">)):</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">download_model_from_hf</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="p">)</span>

        <span class="c1"># Load model weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

        <span class="c1"># Set model to evaluation mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">download_model_from_hf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Download the object detection model from Hugging Face.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the model file.</span>
<span class="sd">            repo_id: Hugging Face repository ID.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to the downloaded model file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model path not specified, downloading from Hugging Face...&quot;</span><span class="p">)</span>

            <span class="c1"># Define the repository ID and model filename</span>
            <span class="k">if</span> <span class="n">repo_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">repo_id</span> <span class="o">=</span> <span class="s2">&quot;giswqs/geoai&quot;</span>

            <span class="k">if</span> <span class="n">model_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_path</span> <span class="o">=</span> <span class="s2">&quot;building_footprints_usa.pth&quot;</span>

            <span class="c1"># Download the model</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="n">hf_hub_download</span><span class="p">(</span><span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">model_path</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model downloaded to: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">model_path</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading model from Hugging Face: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please specify a local model path or ensure internet connectivity.&quot;</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a deep learning model for object detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (torch.nn.Module): A pre-initialized model object.</span>
<span class="sd">            num_classes (int): Number of classes for detection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.nn.Module: A deep learning model for object detection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Initialize Mask R-CNN model with ResNet50 backbone.</span>
            <span class="c1"># Standard image mean and std for pre-trained models</span>
            <span class="n">image_mean</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
            <span class="n">image_std</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>

            <span class="c1"># Create model with explicit normalization parameters</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">maskrcnn_resnet50_fpn</span><span class="p">(</span>
                <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>  <span class="c1"># Background + object</span>
                <span class="n">weights_backbone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="c1"># These parameters ensure consistent normalization</span>
                <span class="n">image_mean</span><span class="o">=</span><span class="n">image_mean</span><span class="p">,</span>
                <span class="n">image_std</span><span class="o">=</span><span class="n">image_std</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">load_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load weights from file with error handling for different formats.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to model weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model file not found: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

            <span class="c1"># Handle different state dict formats</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="s2">&quot;model&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
                    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="s2">&quot;state_dict&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
                    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;state_dict&quot;</span><span class="p">]</span>

            <span class="c1"># Try to load state dict</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model loaded successfully&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempting to fix state_dict keys...&quot;</span><span class="p">)</span>

                <span class="c1"># Try to fix state_dict keys (remove module prefix if needed)</span>
                <span class="n">new_state_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;module.&quot;</span><span class="p">):</span>
                        <span class="n">new_state_dict</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">7</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_state_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">new_state_dict</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model loaded successfully after key fixing&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to load model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mask_to_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert binary mask to polygon contours using OpenCV.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask: Binary mask as numpy array</span>
<span class="sd">            **kwargs: Optional parameters:</span>
<span class="sd">                simplify_tolerance: Tolerance for polygon simplification</span>
<span class="sd">                mask_threshold: Threshold for mask binarization</span>
<span class="sd">                min_object_area: Minimum area in pixels to keep an object</span>
<span class="sd">                max_object_area: Maximum area in pixels to keep an object</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of polygons as lists of (x, y) coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get parameters from kwargs or use instance defaults</span>
        <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simplify_tolerance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span><span class="p">)</span>
        <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
        <span class="n">min_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span><span class="p">)</span>
        <span class="n">max_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span><span class="p">)</span>

        <span class="c1"># Ensure binary mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># Optional: apply morphological operations to improve mask quality</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

        <span class="c1"># Find contours</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span>

        <span class="c1"># Convert to list of [x, y] coordinates</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="c1"># Filter out too small contours</span>
            <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Filter out too large contours</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_object_area</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Simplify contour if it has many points</span>
            <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">simplify_tolerance</span> <span class="o">*</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Convert to list of [x, y] coordinates</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">polygons</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">filter_overlapping_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter overlapping polygons using non-maximum suppression.</span>

<span class="sd">        Args:</span>
<span class="sd">            gdf: GeoDataFrame with polygons</span>
<span class="sd">            **kwargs: Optional parameters:</span>
<span class="sd">                nms_iou_threshold: IoU threshold for filtering</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered GeoDataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gdf</span>

        <span class="c1"># Get parameters from kwargs or use instance defaults</span>
        <span class="n">iou_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nms_iou_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span><span class="p">)</span>

        <span class="c1"># Sort by confidence</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;confidence&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Fix any invalid geometries</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_valid</span> <span class="k">else</span> <span class="n">geom</span>
        <span class="p">)</span>

        <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">:</span>
                <span class="c1"># Skip invalid geometries</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Calculate IoU</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">area</span>
                    <span class="n">union</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">+</span> <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="n">intersection</span>
                    <span class="n">iou</span> <span class="o">=</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">union</span> <span class="k">if</span> <span class="n">union</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">iou</span> <span class="o">&gt;</span> <span class="n">iou_threshold</span><span class="p">:</span>
                        <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Skip on topology exceptions</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="n">keep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">filter_edge_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter out object detections that fall in padding/edge areas of the image.</span>

<span class="sd">        Args:</span>
<span class="sd">            gdf: GeoDataFrame with object detections</span>
<span class="sd">            raster_path: Path to the original raster file</span>
<span class="sd">            edge_buffer: Buffer in pixels to consider as edge region</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with filtered objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">box</span>

        <span class="c1"># If no objects detected, return empty GeoDataFrame</span>
        <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gdf</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects before filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Get raster bounds</span>
            <span class="n">raster_bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">raster_width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
            <span class="n">raster_height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>

            <span class="c1"># Convert edge buffer from pixels to geographic units</span>
            <span class="c1"># We need the smallest dimension of a pixel in geographic units</span>
            <span class="n">pixel_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">raster_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">raster_width</span>
            <span class="n">pixel_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">raster_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">raster_height</span>
            <span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pixel_width</span><span class="p">,</span> <span class="n">pixel_height</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_buffer</span>

            <span class="c1"># Create a slightly smaller bounding box to exclude edge regions</span>
            <span class="n">inner_bounds</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># min x (west)</span>
                <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># min y (south)</span>
                <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># max x (east)</span>
                <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># max y (north)</span>
            <span class="p">)</span>

            <span class="c1"># Check that inner bounds are valid</span>
            <span class="k">if</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Edge buffer too large, using original bounds&quot;</span><span class="p">)</span>
                <span class="n">inner_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">raster_bounds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inner_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">inner_bounds</span><span class="p">)</span>

            <span class="c1"># Filter out objects that intersect with the edge of the image</span>
            <span class="n">filtered_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">inner_box</span><span class="p">)]</span>

            <span class="c1"># Additional check for objects that have &gt;50% of their area outside the valid region</span>
            <span class="n">valid_objects</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">filtered_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">inner_box</span><span class="p">)</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span><span class="p">:</span>
                    <span class="n">valid_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="n">filtered_gdf</span> <span class="o">=</span> <span class="n">filtered_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_objects</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects after filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">filtered_gdf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">masks_to_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mask_path</span><span class="p">,</span>
        <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">simplify_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an object mask GeoTIFF to vector polygons and save as GeoJSON.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask_path: Path to the object masks GeoTIFF</span>
<span class="sd">            output_path: Path to save the output GeoJSON or Parquet file (default: mask_path with .geojson extension)</span>
<span class="sd">            simplify_tolerance: Tolerance for polygon simplification (default: self.simplify_tolerance)</span>
<span class="sd">            mask_threshold: Threshold for mask binarization (default: self.mask_threshold)</span>
<span class="sd">            min_object_area: Minimum area in pixels to keep an object (default: self.min_object_area)</span>
<span class="sd">            max_object_area: Minimum area in pixels to keep an object (default: self.max_object_area)</span>
<span class="sd">            nms_iou_threshold: IoU threshold for non-maximum suppression (default: self.nms_iou_threshold)</span>
<span class="sd">            regularize: Whether to regularize objects to right angles (default: True)</span>
<span class="sd">            angle_threshold: Maximum deviation from 90 degrees for regularization (default: 15)</span>
<span class="sd">            rectangularity_threshold: Threshold for rectangle simplification (default: 0.7)</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use class defaults if parameters not provided</span>
        <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">simplify_tolerance</span>
            <span class="k">if</span> <span class="n">simplify_tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span>
        <span class="p">)</span>
        <span class="n">mask_threshold</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mask_threshold</span> <span class="k">if</span> <span class="n">mask_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span>
        <span class="p">)</span>
        <span class="n">min_object_area</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">min_object_area</span> <span class="k">if</span> <span class="n">min_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span>
        <span class="p">)</span>
        <span class="n">max_object_area</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">max_object_area</span> <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span>
        <span class="p">)</span>
        <span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nms_iou_threshold</span>
            <span class="k">if</span> <span class="n">nms_iou_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span>
        <span class="p">)</span>

        <span class="c1"># Set default output path if not provided</span>
        <span class="c1"># if output_path is None:</span>
        <span class="c1">#     output_path = os.path.splitext(mask_path)[0] + &quot;.geojson&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting mask to GeoJSON with parameters:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min object area: </span><span class="si">{</span><span class="n">min_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Max object area: </span><span class="si">{</span><span class="n">max_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Simplify tolerance: </span><span class="si">{</span><span class="n">simplify_tolerance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- NMS IoU threshold: </span><span class="si">{</span><span class="n">nms_iou_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Regularize objects: </span><span class="si">{</span><span class="n">regularize</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regularize</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Angle threshold: </span><span class="si">{</span><span class="n">angle_threshold</span><span class="si">}</span><span class="s2">° from 90°&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Rectangularity threshold: </span><span class="si">{</span><span class="n">rectangularity_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

        <span class="c1"># Open the mask raster</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Read the mask data</span>
            <span class="n">mask_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

            <span class="c1"># Print mask statistics</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask dimensions: </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask value range: </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Prepare for connected component analysis</span>
            <span class="c1"># Binarize the mask based on threshold</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_data</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">mask_threshold</span> <span class="o">*</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Apply morphological operations for better results (optional)</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

            <span class="c1"># Find connected components</span>
            <span class="n">num_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span>
                <span class="n">binary_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span>
            <span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">num_labels</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> potential objects&quot;</span>
            <span class="p">)</span>  <span class="c1"># Subtract 1 for background</span>

            <span class="c1"># Create list to store polygons and confidence values</span>
            <span class="n">all_polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_confidences</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Process each component (skip the first one which is background)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_labels</span><span class="p">)):</span>
                <span class="c1"># Extract this object</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span>

                <span class="c1"># Skip if too small</span>
                <span class="k">if</span> <span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Skip if too large</span>
                <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Create a mask for this object</span>
                <span class="n">object_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="c1"># Find contours</span>
                <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                    <span class="n">object_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
                <span class="p">)</span>

                <span class="c1"># Process each contour</span>
                <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                    <span class="c1"># Skip if too few points</span>
                    <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Simplify contour if it has many points</span>
                    <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">simplify_tolerance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">simplify_tolerance</span> <span class="o">*</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># Convert to list of (x, y) coordinates</span>
                    <span class="n">polygon_points</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="c1"># Convert pixel coordinates to geographic coordinates</span>
                    <span class="n">geo_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">polygon_points</span><span class="p">:</span>
                        <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">geo_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                    <span class="c1"># Create Shapely polygon</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">and</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely_poly</span><span class="p">)</span>

                                <span class="c1"># Calculate &quot;confidence&quot; as normalized size</span>
                                <span class="c1"># This is a proxy since we don&#39;t have model confidence scores</span>
                                <span class="n">normalized_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">area</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Cap at 1.0</span>
                                <span class="n">all_confidences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalized_size</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating polygon: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_polygons</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid polygons&quot;</span><span class="p">)</span>

            <span class="c1"># Create GeoDataFrame</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_polygons</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">all_polygons</span><span class="p">,</span>
                    <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">all_confidences</span><span class="p">,</span>
                    <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Object class</span>
                <span class="p">},</span>
                <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Apply non-maximum suppression to remove overlapping polygons</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_overlapping_polygons</span><span class="p">(</span>
                <span class="n">gdf</span><span class="p">,</span> <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="n">nms_iou_threshold</span>
            <span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object count after NMS filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Apply regularization if requested</span>
            <span class="k">if</span> <span class="n">regularize</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Convert pixel area to geographic units for min_area parameter</span>
                <span class="c1"># Estimate pixel size in geographic units</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>  <span class="c1"># width of a pixel in geographic units</span>
                    <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="p">)</span>  <span class="c1"># height of a pixel in geographic units</span>
                    <span class="n">avg_pixel_area</span> <span class="o">=</span> <span class="n">pixel_size_x</span> <span class="o">*</span> <span class="n">pixel_size_y</span>

                <span class="c1"># Use 10 pixels as minimum area in geographic units</span>
                <span class="n">min_geo_area</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">avg_pixel_area</span>

                <span class="c1"># Regularize objects</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize_objects</span><span class="p">(</span>
                    <span class="n">gdf</span><span class="p">,</span>
                    <span class="n">min_area</span><span class="o">=</span><span class="n">min_geo_area</span><span class="p">,</span>
                    <span class="n">angle_threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">,</span>
                    <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="n">rectangularity_threshold</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Save to file</span>
            <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.parquet&quot;</span><span class="p">):</span>
                    <span class="n">gdf</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_raster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raster_path</span><span class="p">,</span>
        <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">filter_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a raster file to extract objects with customizable parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            raster_path: Path to input raster file</span>
<span class="sd">            output_path: Path to output GeoJSON or Parquet file (optional)</span>
<span class="sd">            batch_size: Batch size for processing</span>
<span class="sd">            filter_edges: Whether to filter out objects at the edges of the image</span>
<span class="sd">            edge_buffer: Size of edge buffer in pixels to filter out objects (if filter_edges=True)</span>
<span class="sd">            band_indexes: List of band indexes to use (if None, use all bands)</span>
<span class="sd">            **kwargs: Additional parameters:</span>
<span class="sd">                confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)</span>
<span class="sd">                overlap: Overlap between adjacent tiles (0.0-1.0)</span>
<span class="sd">                chip_size: Size of image chips for processing (height, width)</span>
<span class="sd">                nms_iou_threshold: IoU threshold for non-maximum suppression (0.0-1.0)</span>
<span class="sd">                mask_threshold: Threshold for mask binarization (0.0-1.0)</span>
<span class="sd">                min_object_area: Minimum area in pixels to keep an object</span>
<span class="sd">                simplify_tolerance: Tolerance for polygon simplification</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get parameters from kwargs or use instance defaults</span>
        <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;confidence_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
        <span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>
        <span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nms_iou_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span><span class="p">)</span>
        <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
        <span class="n">min_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span><span class="p">)</span>
        <span class="n">max_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span><span class="p">)</span>
        <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simplify_tolerance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span><span class="p">)</span>

        <span class="c1"># Print parameters being used</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing with parameters:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Confidence threshold: </span><span class="si">{</span><span class="n">confidence_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Tile overlap: </span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Chip size: </span><span class="si">{</span><span class="n">chip_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- NMS IoU threshold: </span><span class="si">{</span><span class="n">nms_iou_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min object area: </span><span class="si">{</span><span class="n">min_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Max object area: </span><span class="si">{</span><span class="n">max_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Simplify tolerance: </span><span class="si">{</span><span class="n">simplify_tolerance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Filter edge objects: </span><span class="si">{</span><span class="n">filter_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filter_edges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Edge buffer size: </span><span class="si">{</span><span class="n">edge_buffer</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>

        <span class="c1"># Create dataset</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
            <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
            <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">band_indexes</span><span class="o">=</span><span class="n">band_indexes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">raster_stats</span>

        <span class="c1"># Custom collate function to handle Shapely objects</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Custom collate function that handles Shapely geometries</span>
<span class="sd">            by keeping them as Python objects rather than trying to collate them.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For tensors and other collatable types</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="c1"># Fall back to list for non-collatable types</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default collate for non-dict types</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

        <span class="c1"># Create dataloader with simple indexing and custom collate</span>
        <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Process batches</span>
        <span class="n">all_polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_scores</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
            <span class="c1"># Move images to device</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># (i, j) coordinates in pixels</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span>
                <span class="s2">&quot;bbox&quot;</span>
            <span class="p">]</span>  <span class="c1"># Geographic bounding boxes - now a list, not a tensor</span>

            <span class="c1"># Run inference</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

            <span class="c1"># Process predictions</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="c1"># Skip if no predictions</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Filter by confidence threshold</span>
                <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
                <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

                <span class="c1"># Skip if no valid predictions</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Get window coordinates</span>
                <span class="c1"># The coords might be in different formats depending on batch handling</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># If coords is a list of tuples</span>
                    <span class="n">coord_item</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="c1"># If coords is a tensor of shape [batch_size, 2]</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Get window size</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">window_item</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected window_size format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected window_size type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s1">&#39;window_size&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Process masks to polygons</span>
                <span class="k">for</span> <span class="n">mask_idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
                    <span class="c1"># Get binary mask</span>
                    <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Get binary mask</span>

                    <span class="c1"># Convert mask to polygon with custom parameters</span>
                    <span class="n">contours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_to_polygons</span><span class="p">(</span>
                        <span class="n">binary_mask</span><span class="p">,</span>
                        <span class="n">simplify_tolerance</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span>
                        <span class="n">mask_threshold</span><span class="o">=</span><span class="n">mask_threshold</span><span class="p">,</span>
                        <span class="n">min_object_area</span><span class="o">=</span><span class="n">min_object_area</span><span class="p">,</span>
                        <span class="n">max_object_area</span><span class="o">=</span><span class="n">max_object_area</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Skip if no valid polygons</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">contours</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Transform polygons to geographic coordinates</span>
                    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                        <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

                        <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                            <span class="c1"># Convert polygon to global coordinates</span>
                            <span class="n">global_polygon</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">contour</span><span class="p">:</span>
                                <span class="c1"># Adjust coordinates based on window position</span>
                                <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">global_polygon</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                            <span class="c1"># Create Shapely polygon</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">global_polygon</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">global_polygon</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">and</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely_poly</span><span class="p">)</span>
                                        <span class="n">all_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">mask_idx</span><span class="p">]))</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating polygon: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create GeoDataFrame</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_polygons</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">all_polygons</span><span class="p">,</span>
                <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">all_scores</span><span class="p">,</span>
                <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Object class</span>
            <span class="p">},</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Remove overlapping polygons with custom threshold</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_overlapping_polygons</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="n">nms_iou_threshold</span><span class="p">)</span>

        <span class="c1"># Filter edge objects if requested</span>
        <span class="k">if</span> <span class="n">filter_edges</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_edge_objects</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="n">edge_buffer</span><span class="p">)</span>

        <span class="c1"># Save to file if requested</span>
        <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.parquet&quot;</span><span class="p">):</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save_masks_as_geotiff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a raster file to extract object masks and save as GeoTIFF.</span>

<span class="sd">        Args:</span>
<span class="sd">            raster_path: Path to input raster file</span>
<span class="sd">            output_path: Path to output GeoTIFF file (optional, default: input_masks.tif)</span>
<span class="sd">            batch_size: Batch size for processing</span>
<span class="sd">            verbose: Whether to print detailed processing information</span>
<span class="sd">            **kwargs: Additional parameters:</span>
<span class="sd">                confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)</span>
<span class="sd">                chip_size: Size of image chips for processing (height, width)</span>
<span class="sd">                mask_threshold: Threshold for mask binarization (0.0-1.0)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to the saved GeoTIFF file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get parameters from kwargs or use instance defaults</span>
        <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;confidence_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
        <span class="p">)</span>
        <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>
        <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>

        <span class="c1"># Set default output path if not provided</span>
        <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_masks.tif&quot;</span>

        <span class="c1"># Print parameters being used</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing masks with parameters:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Confidence threshold: </span><span class="si">{</span><span class="n">confidence_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Chip size: </span><span class="si">{</span><span class="n">chip_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create dataset</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
            <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
            <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Store a flag to avoid repetitive messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">raster_stats</span>
        <span class="n">seen_warnings</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;bands&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;resize&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># Dictionary to track resize warnings by shape</span>
        <span class="p">}</span>

        <span class="c1"># Open original raster to get metadata</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Create output binary mask raster with same dimensions as input</span>
            <span class="n">output_profile</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">output_profile</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Single band for object mask</span>
                <span class="n">compress</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Create output mask raster</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">output_profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="c1"># Initialize mask with zeros</span>
                <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="c1"># Custom collate function to handle Shapely objects</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Custom collate function for DataLoader&quot;&quot;&quot;</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                                <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># For tensors and other collatable types</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                            <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                                        <span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                                    <span class="c1"># Fall back to list for non-collatable types</span>
                                    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                        <span class="k">return</span> <span class="n">result</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Default collate for non-dict types</span>
                        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

                <span class="c1"># Create dataloader</span>
                <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="p">,</span>
                    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                    <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Process batches</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
                    <span class="c1"># Move images to device</span>
                    <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># (i, j) coordinates in pixels</span>

                    <span class="c1"># Run inference</span>
                    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

                    <span class="c1"># Process predictions</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                        <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                        <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                        <span class="c1"># Skip if no predictions</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Filter by confidence threshold</span>
                        <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
                        <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                        <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

                        <span class="c1"># Skip if no valid predictions</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Get window coordinates</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">coord_item</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span>
                            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="k">continue</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>

                        <span class="c1"># Get window size</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">window_item</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span>
                            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                                <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">window_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Unexpected window_size format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                                <span class="k">continue</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                            <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Unexpected window_size type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s1">&#39;window_size&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="k">continue</span>

                        <span class="c1"># Combine all masks for this window</span>
                        <span class="n">combined_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">window_height</span><span class="p">,</span> <span class="n">window_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                        <span class="p">)</span>

                        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
                            <span class="c1"># Get the binary mask</span>
                            <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                            <span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

                            <span class="c1"># Handle size mismatch - resize binary_mask if needed</span>
                            <span class="n">mask_h</span><span class="p">,</span> <span class="n">mask_w</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span>
                            <span class="k">if</span> <span class="n">mask_h</span> <span class="o">!=</span> <span class="n">window_height</span> <span class="ow">or</span> <span class="n">mask_w</span> <span class="o">!=</span> <span class="n">window_width</span><span class="p">:</span>
                                <span class="n">resize_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">mask_h</span><span class="p">,</span><span class="w"> </span><span class="n">mask_w</span><span class="p">)</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="p">(</span><span class="n">window_height</span><span class="p">,</span><span class="w"> </span><span class="n">window_width</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="k">if</span> <span class="n">resize_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_warnings</span><span class="p">[</span><span class="s2">&quot;resize&quot;</span><span class="p">]:</span>
                                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                        <span class="nb">print</span><span class="p">(</span>
                                            <span class="sa">f</span><span class="s2">&quot;Resizing mask from </span><span class="si">{</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="p">(</span><span class="n">window_height</span><span class="p">,</span><span class="w"> </span><span class="n">window_width</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_warnings</span><span class="p">[</span>
                                            <span class="s2">&quot;resize&quot;</span>
                                        <span class="p">]:</span>  <span class="c1"># If this is the first resize warning</span>
                                            <span class="nb">print</span><span class="p">(</span>
                                                <span class="sa">f</span><span class="s2">&quot;Resizing masks at image edges (set verbose=True for details)&quot;</span>
                                            <span class="p">)</span>
                                    <span class="n">seen_warnings</span><span class="p">[</span><span class="s2">&quot;resize&quot;</span><span class="p">][</span><span class="n">resize_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                                <span class="c1"># Crop or pad the binary mask to match window size</span>
                                <span class="n">resized_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">window_height</span><span class="p">,</span> <span class="n">window_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                                <span class="p">)</span>
                                <span class="n">copy_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mask_h</span><span class="p">,</span> <span class="n">window_height</span><span class="p">)</span>
                                <span class="n">copy_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mask_w</span><span class="p">,</span> <span class="n">window_width</span><span class="p">)</span>
                                <span class="n">resized_mask</span><span class="p">[:</span><span class="n">copy_h</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="p">[</span>
                                    <span class="p">:</span><span class="n">copy_h</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_w</span>
                                <span class="p">]</span>
                                <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">resized_mask</span>

                            <span class="c1"># Update combined mask (taking maximum where masks overlap)</span>
                            <span class="n">combined_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">combined_mask</span><span class="p">,</span> <span class="n">binary_mask</span><span class="p">)</span>

                        <span class="c1"># Write combined mask to output array</span>
                        <span class="c1"># Handle edge cases where window might be smaller than chip size</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">combined_mask</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">valid_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>
                        <span class="n">valid_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">valid_h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">valid_w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">],</span>
                                <span class="n">combined_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">],</span>
                            <span class="p">)</span>

                <span class="c1"># Write the final mask to the output file</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object masks saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_path</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">regularize_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regularize objects to enforce right angles and rectangular shapes.</span>

<span class="sd">        Args:</span>
<span class="sd">            gdf: GeoDataFrame with objects</span>
<span class="sd">            min_area: Minimum area in square units to keep an object</span>
<span class="sd">            angle_threshold: Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</span>
<span class="sd">            orthogonality_threshold: Percentage of angles that must be orthogonal for an object to be regularized</span>
<span class="sd">            rectangularity_threshold: Minimum area ratio to Object&#39;s oriented bounding box for rectangular simplification</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with regularized objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.affinity</span><span class="w"> </span><span class="kn">import</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">translate</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">box</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_angle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Calculate angle between three points in degrees (0-180)&quot;&quot;&quot;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p3</span><span class="p">)</span>

            <span class="n">ba</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span>

            <span class="n">cosine_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ba</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bc</span><span class="p">))</span>
            <span class="c1"># Handle numerical errors that could push cosine outside [-1, 1]</span>
            <span class="n">cosine_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cosine_angle</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosine_angle</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">angle</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">is_orthogonal</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Check if angle is close to 90 degrees&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dominant_direction</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Find the dominant direction of a polygon using PCA&quot;&quot;&quot;</span>
            <span class="c1"># Extract coordinates</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

            <span class="c1"># Mean center the coordinates</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">centered_coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">-</span> <span class="n">mean</span>

            <span class="c1"># Calculate covariance matrix and its eigenvalues/eigenvectors</span>
            <span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">centered_coords</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>

            <span class="c1"># Get the index of the largest eigenvalue</span>
            <span class="n">largest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>

            <span class="c1"># Get the corresponding eigenvector (principal axis)</span>
            <span class="n">principal_axis</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">largest_idx</span><span class="p">]</span>

            <span class="c1"># Calculate the angle in degrees</span>
            <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">principal_axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">principal_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">angle_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)</span>

            <span class="c1"># Normalize to range 0-180</span>
            <span class="k">if</span> <span class="n">angle_deg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">angle_deg</span> <span class="o">+=</span> <span class="mi">180</span>

            <span class="k">return</span> <span class="n">angle_deg</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_oriented_envelope</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">angle_deg</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Create an oriented minimum area rectangle for the polygon&quot;&quot;&quot;</span>
            <span class="c1"># Create a rotated rectangle using OpenCV method (more robust than Shapely methods)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>  <span class="c1"># Skip the last point (same as first)</span>

            <span class="c1"># Use OpenCV&#39;s minAreaRect</span>
            <span class="n">rect</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">box_points</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>

            <span class="c1"># Convert to shapely polygon</span>
            <span class="n">oriented_box</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">box_points</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">oriented_box</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_rectangularity</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">oriented_box</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Calculate the rectangularity (area ratio to its oriented bounding box)&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">oriented_box</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">oriented_box</span><span class="o">.</span><span class="n">area</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_orthogonality</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Check what percentage of angles in the polygon are orthogonal&quot;&quot;&quot;</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># Triangle or point</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="c1"># Remove last point (same as first)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">orthogonal_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">total_angles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_angles</span><span class="p">):</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_angles</span><span class="p">]</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_angles</span><span class="p">]</span>

                <span class="n">angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_orthogonal</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
                    <span class="n">orthogonal_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">orthogonal_count</span> <span class="o">/</span> <span class="n">total_angles</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">simplify_to_rectangle</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Simplify a polygon to a rectangle using its oriented bounding box&quot;&quot;&quot;</span>
            <span class="c1"># Get dominant direction</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_dominant_direction</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

            <span class="c1"># Create oriented envelope</span>
            <span class="n">rect</span> <span class="o">=</span> <span class="n">create_oriented_envelope</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">rect</span>

        <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Objects to regularize&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gdf</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Regularizing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects...&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Angle threshold: </span><span class="si">{</span><span class="n">angle_threshold</span><span class="si">}</span><span class="s2">° from 90°&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min orthogonality: </span><span class="si">{</span><span class="n">orthogonality_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of angles&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;- Min rectangularity: </span><span class="si">{</span><span class="n">rectangularity_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of bounding box area&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create a copy to avoid modifying the original</span>
        <span class="n">result_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Track statistics</span>
        <span class="n">total_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
        <span class="n">regularized_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rectangularized_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Process each Object</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)):</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span>

            <span class="c1"># Skip invalid or empty geometries</span>
            <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Handle MultiPolygons by processing the largest part</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">areas</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">areas</span><span class="p">)]</span>

            <span class="c1"># Filter out tiny Objects</span>
            <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_area</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Check orthogonality</span>
            <span class="n">orthogonality</span> <span class="o">=</span> <span class="n">check_orthogonality</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>

            <span class="c1"># Create oriented envelope</span>
            <span class="n">oriented_box</span> <span class="o">=</span> <span class="n">create_oriented_envelope</span><span class="p">(</span>
                <span class="n">geom</span><span class="p">,</span> <span class="n">calculate_dominant_direction</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Check rectangularity</span>
            <span class="n">rectangularity</span> <span class="o">=</span> <span class="n">get_rectangularity</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">oriented_box</span><span class="p">)</span>

            <span class="c1"># Decide how to regularize</span>
            <span class="k">if</span> <span class="n">rectangularity</span> <span class="o">&gt;=</span> <span class="n">rectangularity_threshold</span><span class="p">:</span>
                <span class="c1"># Object is already quite rectangular, simplify to a rectangle</span>
                <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oriented_box</span>
                <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rectangle&quot;</span>
                <span class="n">rectangularized_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">orthogonality</span> <span class="o">&gt;=</span> <span class="n">orthogonality_threshold</span><span class="p">:</span>
                <span class="c1"># Object has many orthogonal angles but isn&#39;t rectangular</span>
                <span class="c1"># Could implement more sophisticated regularization here</span>
                <span class="c1"># For now, we&#39;ll still use the oriented rectangle</span>
                <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oriented_box</span>
                <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;orthogonal&quot;</span>
                <span class="n">regularized_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Object doesn&#39;t have clear orthogonal structure</span>
                <span class="c1"># Keep original but flag as unmodified</span>
                <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;original&quot;</span>

        <span class="c1"># Report statistics</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Regularization completed:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Total objects: </span><span class="si">{</span><span class="n">total_objects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;- Rectangular objects: </span><span class="si">{</span><span class="n">rectangularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">rectangularized_count</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;- Other regularized objects: </span><span class="si">{</span><span class="n">regularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">regularized_count</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;- Unmodified objects: </span><span class="si">{</span><span class="n">total_objects</span><span class="o">-</span><span class="n">rectangularized_count</span><span class="o">-</span><span class="n">regularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="p">(</span><span class="n">total_objects</span><span class="o">-</span><span class="n">rectangularized_count</span><span class="o">-</span><span class="n">regularized_count</span><span class="p">)</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result_gdf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visualize_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">gdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize object detection results with proper coordinate transformation.</span>

<span class="sd">        This function displays objects on top of the raster image,</span>
<span class="sd">        ensuring proper alignment between the GeoDataFrame polygons and the image.</span>

<span class="sd">        Args:</span>
<span class="sd">            raster_path: Path to input raster</span>
<span class="sd">            gdf: GeoDataFrame with object polygons (optional)</span>
<span class="sd">            output_path: Path to save visualization (optional)</span>
<span class="sd">            figsize: Figure size (width, height) in inches</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if visualization was successful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if raster file exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">raster_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Raster file &#39;</span><span class="si">{</span><span class="n">raster_path</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Process raster if GeoDataFrame not provided</span>
        <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_raster</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No objects to visualize&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check if confidence column exists in the GeoDataFrame</span>
        <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;confidence&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Try to access a confidence value to confirm it works</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Try getitem access</span>
                    <span class="n">conf_val</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Using confidence values (range: </span><span class="si">{</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confidence column exists but couldn&#39;t access values: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No confidence column found in GeoDataFrame&quot;</span><span class="p">)</span>
            <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Read raster for visualization</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Read the entire image or a subset if it&#39;s very large</span>
            <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">2000</span> <span class="ow">or</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
                <span class="c1"># Calculate scale factor to reduce size</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2000</span> <span class="o">/</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">2000</span> <span class="o">/</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">count</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="c1"># Read and resample</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                    <span class="n">out_shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">resampling</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">enums</span><span class="o">.</span><span class="n">Resampling</span><span class="o">.</span><span class="n">bilinear</span>
                <span class="p">)</span>

                <span class="c1"># Create a scaled transform for the resampled image</span>
                <span class="c1"># Calculate scaling factors</span>
                <span class="n">x_scale</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">out_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y_scale</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">out_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Get the original transform</span>
                <span class="n">orig_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

                <span class="c1"># Create a scaled transform</span>
                <span class="n">scaled_transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">d</span><span class="p">,</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">,</span>
                    <span class="n">orig_transform</span><span class="o">.</span><span class="n">f</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">scaled_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

            <span class="c1"># Convert to RGB for display</span>
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Normalize image for display</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># CHW to HWC</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Likely 0-255 range</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>

            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Get image bounds</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

        <span class="c1"># Create figure with appropriate aspect ratio</span>
        <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># width / height</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">aspect_ratio</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="c1"># Display image</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Make sure the GeoDataFrame has the same CRS as the raster</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">crs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reprojecting GeoDataFrame from </span><span class="si">{</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

        <span class="c1"># Set up colors for confidence visualization</span>
        <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.cm</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cm</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Normalize</span>

                <span class="c1"># Get min/max confidence values</span>
                <span class="n">min_conf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">max_conf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                <span class="c1"># Set up normalization and colormap</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">min_conf</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_conf</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">viridis</span>

                <span class="c1"># Create scalar mappable for colorbar</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
                <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

                <span class="c1"># Add colorbar</span>
                <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                    <span class="n">sm</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span>
                <span class="p">)</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Confidence Score&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting up confidence visualization: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Function to convert coordinates</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">geo_to_pixel</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Convert geometry to pixel coordinates using the provided transform.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
                <span class="c1"># Get exterior coordinates</span>
                <span class="n">exterior_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

                <span class="c1"># Convert to pixel coordinates</span>
                <span class="n">pixel_coords</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">exterior_coords</span><span class="p">]</span>

                <span class="c1"># Split into x and y lists</span>
                <span class="n">pixel_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>
                <span class="n">pixel_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported geometry type: </span><span class="si">{</span><span class="n">geometry</span><span class="o">.</span><span class="n">geom_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Plot each object</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Convert polygon to pixel coordinates</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">geo_to_pixel</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">scaled_transform</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
                    <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span> <span class="o">=</span> <span class="n">coords</span>

                    <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># Get confidence value using different methods</span>
                            <span class="c1"># Method 1: Try direct attribute access</span>
                            <span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">confidence</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                            <span class="c1"># Method 2: Try dictionary-style access</span>
                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>

                            <span class="c1"># Method 3: Try accessing by index from the GeoDataFrame</span>
                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>

                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">confidence</span><span class="p">))</span>
                                <span class="c1"># Fill polygon with semi-transparent color</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                                <span class="c1"># Draw border</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                    <span class="n">pixel_x</span><span class="p">,</span>
                                    <span class="n">pixel_y</span><span class="p">,</span>
                                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                    <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Fall back to red if confidence value couldn&#39;t be accessed</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Error using confidence value for polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># No confidence data, just plot outlines in red</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error plotting polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Remove axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;objects (Found: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Visualization saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Create a simpler visualization focused just on a subset of objects</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

            <span class="c1"># Choose a subset of the image to show</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># Get centroid of first object</span>
                <span class="n">sample_geom</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
                <span class="n">centroid</span> <span class="o">=</span> <span class="n">sample_geom</span><span class="o">.</span><span class="n">centroid</span>

                <span class="c1"># Convert to pixel coordinates</span>
                <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

                <span class="c1"># Define a window around this object</span>
                <span class="n">window_size</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># pixels</span>
                <span class="n">window</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                    <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                    <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="p">)</span>

                <span class="c1"># Read this window</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

                <span class="c1"># Convert to RGB for display</span>
                <span class="k">if</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sample_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Normalize image for display</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># CHW to HWC</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Likely 0-255 range</span>
                    <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span> <span class="o">/</span> <span class="mf">255.0</span>

                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Display sample image</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Get the correct transform for this window</span>
                <span class="n">window_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">window_transform</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

                <span class="c1"># Calculate bounds of the window</span>
                <span class="n">window_bounds</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
                <span class="n">window_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">window_bounds</span><span class="p">)</span>

                <span class="c1"># Filter objects that intersect with this window</span>
                <span class="n">visible_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">window_box</span><span class="p">)]</span>

                <span class="c1"># Set up colors for sample view if confidence data exists</span>
                <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Reuse the same normalization and colormap from main view</span>
                        <span class="n">sample_sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
                        <span class="n">sample_sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

                        <span class="c1"># Add colorbar to sample view</span>
                        <span class="n">sample_cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                            <span class="n">sample_sm</span><span class="p">,</span>
                            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                            <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span>
                            <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                            <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">sample_cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Confidence Score&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting up sample confidence visualization: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Plot objects in sample view</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">visible_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Get window-relative pixel coordinates</span>
                        <span class="n">geom</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span>

                        <span class="c1"># Skip empty geometries</span>
                        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Get exterior coordinates</span>
                        <span class="n">exterior_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

                        <span class="c1"># Convert to pixel coordinates relative to window origin</span>
                        <span class="n">pixel_coords</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">exterior_coords</span><span class="p">:</span>
                            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># Convert to image pixels</span>
                            <span class="c1"># Make coordinates relative to window</span>
                            <span class="n">px</span> <span class="o">=</span> <span class="n">px</span> <span class="o">-</span> <span class="n">window</span><span class="o">.</span><span class="n">col_off</span>
                            <span class="n">py</span> <span class="o">=</span> <span class="n">py</span> <span class="o">-</span> <span class="n">window</span><span class="o">.</span><span class="n">row_off</span>
                            <span class="n">pixel_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span>

                        <span class="c1"># Extract x and y coordinates</span>
                        <span class="n">pixel_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>
                        <span class="n">pixel_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>

                        <span class="c1"># Use confidence colors if available</span>
                        <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># Try different methods to access confidence</span>
                                <span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">confidence</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>

                                <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                    <span class="k">except</span><span class="p">:</span>
                                        <span class="k">pass</span>

                                <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="n">confidence</span> <span class="o">=</span> <span class="n">visible_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                    <span class="k">except</span><span class="p">:</span>
                                        <span class="k">pass</span>

                                <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">confidence</span><span class="p">))</span>
                                    <span class="c1"># Fill polygon with semi-transparent color</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                                    <span class="c1"># Draw border</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                        <span class="n">pixel_x</span><span class="p">,</span>
                                        <span class="n">pixel_y</span><span class="p">,</span>
                                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                        <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                        <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span>
                                    <span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Error using confidence in sample view for polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error plotting polygon in sample view: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Set title</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample Area - objects (Showing: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">visible_gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                <span class="c1"># Remove axes</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
                    <span class="n">sample_output</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">+</span> <span class="s2">&quot;_sample&quot;</span>
                        <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">sample_output</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample visualization saved to </span><span class="si">{</span><span class="n">sample_output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_masks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raster_path</span><span class="p">,</span>
        <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">confidence_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_object_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">max_object_area</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
        <span class="n">overlap</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save masks with confidence values as a multi-band GeoTIFF.</span>

<span class="sd">        Objects with area smaller than min_object_area or larger than max_object_area</span>
<span class="sd">        will be filtered out.</span>

<span class="sd">        Args:</span>
<span class="sd">            raster_path: Path to input raster</span>
<span class="sd">            output_path: Path for output GeoTIFF</span>
<span class="sd">            confidence_threshold: Minimum confidence score (0.0-1.0)</span>
<span class="sd">            mask_threshold: Threshold for mask binarization (0.0-1.0)</span>
<span class="sd">            min_object_area: Minimum area (in pixels) for an object to be included</span>
<span class="sd">            max_object_area: Maximum area (in pixels) for an object to be included</span>
<span class="sd">            overlap: Overlap between tiles (0.0-1.0)</span>
<span class="sd">            batch_size: Batch size for processing</span>
<span class="sd">            band_indexes: List of band indexes to use (default: all bands)</span>
<span class="sd">            verbose: Whether to print detailed processing information</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to the saved GeoTIFF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use provided thresholds or fall back to instance defaults</span>
        <span class="k">if</span> <span class="n">confidence_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
        <span class="k">if</span> <span class="n">mask_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span>

        <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>

        <span class="c1"># Default output path</span>
        <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_masks_conf.tif&quot;</span>

        <span class="c1"># Process the raster to get individual masks with confidence</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Create dataset with the specified overlap</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
                <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
                <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
                <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                <span class="n">band_indexes</span><span class="o">=</span><span class="n">band_indexes</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Create output profile</span>
            <span class="n">output_profile</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">output_profile</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Two bands: mask and confidence</span>
                <span class="n">compress</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Initialize mask and confidence arrays</span>
            <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">conf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Define custom collate function to handle Shapely objects</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Custom collate function that handles Shapely geometries</span>
<span class="sd">                by keeping them as Python objects rather than trying to collate them.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                            <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># For tensors and other collatable types</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                                <span class="c1"># Fall back to list for non-collatable types</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Default collate for non-dict types</span>
                    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

            <span class="c1"># Create dataloader with custom collate function</span>
            <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
                <span class="n">dataset</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Process batches</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
                <span class="c1"># Move images to device</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># Tensor of shape [batch_size, 2]</span>

                <span class="c1"># Run inference</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

                <span class="c1"># Process predictions</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                    <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                    <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                    <span class="c1"># Filter by confidence threshold</span>
                    <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
                    <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                    <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

                    <span class="c1"># Skip if no valid predictions</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Get window coordinates</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                    <span class="c1"># Process each mask</span>
                    <span class="k">for</span> <span class="n">mask_idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
                        <span class="c1"># Convert to binary mask</span>
                        <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

                        <span class="c1"># Check object area - calculate number of pixels in the mask</span>
                        <span class="n">object_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># Skip objects that don&#39;t meet area criteria</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">object_area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span>
                            <span class="ow">or</span> <span class="n">object_area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Filtering out object with area </span><span class="si">{</span><span class="n">object_area</span><span class="si">}</span><span class="s2"> pixels&quot;</span>
                                <span class="p">)</span>
                            <span class="k">continue</span>

                        <span class="n">conf_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">mask_idx</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>  <span class="c1"># Scale to 0-255</span>

                        <span class="c1"># Update the mask and confidence arrays</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">valid_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>
                        <span class="n">valid_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">valid_h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">valid_w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Use maximum for overlapping regions in the mask</span>
                            <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">],</span>
                                <span class="n">binary_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">],</span>
                            <span class="p">)</span>

                            <span class="c1"># For confidence, only update where mask is positive</span>
                            <span class="c1"># and confidence is higher than existing</span>
                            <span class="n">mask_region</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_region</span><span class="p">):</span>
                                <span class="c1"># Only update where mask is positive and new confidence is higher</span>
                                <span class="n">current_conf</span> <span class="o">=</span> <span class="n">conf_array</span><span class="p">[</span>
                                    <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span>
                                <span class="p">]</span>

                                <span class="c1"># Where to update confidence (mask positive &amp; higher confidence)</span>
                                <span class="n">update_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                    <span class="n">mask_region</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                                        <span class="n">current_conf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_conf</span> <span class="o">&lt;</span> <span class="n">conf_value</span>
                                    <span class="p">),</span>
                                <span class="p">)</span>

                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">update_mask</span><span class="p">):</span>
                                    <span class="n">conf_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">][</span>
                                        <span class="n">update_mask</span>
                                    <span class="p">]</span> <span class="o">=</span> <span class="n">conf_value</span>

            <span class="c1"># Write to GeoTIFF</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">output_profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">conf_array</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Masks with confidence values saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">output_path</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vectorize_masks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">masks_path</span><span class="p">,</span>
        <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">confidence_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">min_object_area</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert masks with confidence to vector polygons.</span>

<span class="sd">        Args:</span>
<span class="sd">            masks_path: Path to masks GeoTIFF with confidence band.</span>
<span class="sd">            output_path: Path for output GeoJSON.</span>
<span class="sd">            confidence_threshold: Minimum confidence score (0.0-1.0). Default: 0.5</span>
<span class="sd">            min_object_area: Minimum area in pixels to keep an object. Default: 100</span>
<span class="sd">            max_object_area: Maximum area in pixels to keep an object. Default: None</span>
<span class="sd">            **kwargs: Additional parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeoDataFrame with car detections and confidence values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing masks from: </span><span class="si">{</span><span class="n">masks_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">masks_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Read mask and confidence bands</span>
            <span class="n">mask_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">conf_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

            <span class="c1"># Convert to binary mask</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask_data</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c1"># Find connected components</span>
            <span class="n">labeled_mask</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">num_features</span><span class="si">}</span><span class="s2"> connected components&quot;</span><span class="p">)</span>

            <span class="c1"># Process each component</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">confidences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">pixels</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Add progress bar</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing components&quot;</span><span class="p">):</span>
                <span class="c1"># Create mask for this component</span>
                <span class="n">component_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labeled_mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="c1"># Get confidence value (mean of non-zero values in this region)</span>
                <span class="n">conf_region</span> <span class="o">=</span> <span class="n">conf_data</span><span class="p">[</span><span class="n">component_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conf_region</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">confidence</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">conf_region</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
                    <span class="p">)</span>  <span class="c1"># Convert back to 0-1 range</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">confidence</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="c1"># Skip if confidence is below threshold</span>
                <span class="k">if</span> <span class="n">confidence</span> <span class="o">&lt;</span> <span class="n">confidence_threshold</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Find contours</span>
                <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                    <span class="n">component_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                    <span class="c1"># Filter by size</span>
                    <span class="n">area</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="c1"># Get minimum area rectangle</span>
                    <span class="n">rect</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
                    <span class="n">box_points</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>

                    <span class="c1"># Convert to geographic coordinates</span>
                    <span class="n">geo_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">box_points</span><span class="p">:</span>
                        <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">geo_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                    <span class="c1"># Create polygon</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span>

                    <span class="c1"># Add to lists</span>
                    <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                    <span class="n">confidences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confidence</span><span class="p">)</span>
                    <span class="n">pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

            <span class="c1"># Create GeoDataFrame</span>
            <span class="k">if</span> <span class="n">polygons</span><span class="p">:</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">polygons</span><span class="p">,</span>
                        <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">confidences</span><span class="p">,</span>
                        <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">),</span>
                        <span class="s2">&quot;pixels&quot;</span><span class="p">:</span> <span class="n">pixels</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Save to file if requested</span>
                <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
                    <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects with confidence to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">gdf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.ObjectDetector.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Hugging Face repository ID for model download.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Pre-initialized model object (optional).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>num_classes</code></td>
        <td></td>
        <td><p>Number of classes for detection (default: 2).</p></td>
        <td><code>2</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Hugging Face repository ID for model download.</span>
<span class="sd">        model: Pre-initialized model object (optional).</span>
<span class="sd">        num_classes: Number of classes for detection (default: 2).</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set device</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># Default parameters for object detection - these can be overridden in process_raster</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>  <span class="c1"># Size of image chips for processing</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.25</span>  <span class="c1"># Default overlap between tiles</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Default confidence threshold</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># IoU threshold for non-maximum suppression</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Minimum area in pixels to keep an object</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Maximum area in pixels to keep an object</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Threshold for mask binarization</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Tolerance for polygon simplification</span>

    <span class="c1"># Initialize model</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">)</span>

    <span class="c1"># Download model if needed</span>
    <span class="k">if</span> <span class="n">model_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">)):</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">download_model_from_hf</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="p">)</span>

    <span class="c1"># Load model weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

    <span class="c1"># Set model to evaluation mode</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.download_model_from_hf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">download_model_from_hf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.download_model_from_hf" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Download the object detection model from Hugging Face.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the model file.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Hugging Face repository ID.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>Path to the downloaded model file</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">download_model_from_hf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download the object detection model from Hugging Face.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the model file.</span>
<span class="sd">        repo_id: Hugging Face repository ID.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Path to the downloaded model file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model path not specified, downloading from Hugging Face...&quot;</span><span class="p">)</span>

        <span class="c1"># Define the repository ID and model filename</span>
        <span class="k">if</span> <span class="n">repo_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">repo_id</span> <span class="o">=</span> <span class="s2">&quot;giswqs/geoai&quot;</span>

        <span class="k">if</span> <span class="n">model_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="s2">&quot;building_footprints_usa.pth&quot;</span>

        <span class="c1"># Download the model</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">hf_hub_download</span><span class="p">(</span><span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">model_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model downloaded to: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_path</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading model from Hugging Face: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please specify a local model path or ensure internet connectivity.&quot;</span><span class="p">)</span>
        <span class="k">raise</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.filter_edge_objects" class="doc doc-heading">
<code class="highlight language-python"><span class="n">filter_edge_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.filter_edge_objects" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Filter out object detections that fall in padding/edge areas of the image.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td></td>
        <td><p>GeoDataFrame with object detections</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to the original raster file</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>edge_buffer</code></td>
        <td></td>
        <td><p>Buffer in pixels to consider as edge region</p></td>
        <td><code>10</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with filtered objects</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">filter_edge_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter out object detections that fall in padding/edge areas of the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf: GeoDataFrame with object detections</span>
<span class="sd">        raster_path: Path to the original raster file</span>
<span class="sd">        edge_buffer: Buffer in pixels to consider as edge region</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with filtered objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">box</span>

    <span class="c1"># If no objects detected, return empty GeoDataFrame</span>
    <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects before filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Get raster bounds</span>
        <span class="n">raster_bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">raster_width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
        <span class="n">raster_height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>

        <span class="c1"># Convert edge buffer from pixels to geographic units</span>
        <span class="c1"># We need the smallest dimension of a pixel in geographic units</span>
        <span class="n">pixel_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">raster_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">raster_width</span>
        <span class="n">pixel_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">raster_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">raster_height</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pixel_width</span><span class="p">,</span> <span class="n">pixel_height</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_buffer</span>

        <span class="c1"># Create a slightly smaller bounding box to exclude edge regions</span>
        <span class="n">inner_bounds</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># min x (west)</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># min y (south)</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># max x (east)</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">,</span>  <span class="c1"># max y (north)</span>
        <span class="p">)</span>

        <span class="c1"># Check that inner bounds are valid</span>
        <span class="k">if</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">inner_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Edge buffer too large, using original bounds&quot;</span><span class="p">)</span>
            <span class="n">inner_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">raster_bounds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">inner_bounds</span><span class="p">)</span>

        <span class="c1"># Filter out objects that intersect with the edge of the image</span>
        <span class="n">filtered_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">inner_box</span><span class="p">)]</span>

        <span class="c1"># Additional check for objects that have &gt;50% of their area outside the valid region</span>
        <span class="n">valid_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">filtered_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">inner_box</span><span class="p">)</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span><span class="p">:</span>
                <span class="n">valid_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">filtered_gdf</span> <span class="o">=</span> <span class="n">filtered_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_objects</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects after filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.filter_overlapping_polygons" class="doc doc-heading">
<code class="highlight language-python"><span class="n">filter_overlapping_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.filter_overlapping_polygons" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Filter overlapping polygons using non-maximum suppression.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td></td>
        <td><p>GeoDataFrame with polygons</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Optional parameters:
nms_iou_threshold: IoU threshold for filtering</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>Filtered GeoDataFrame</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">filter_overlapping_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter overlapping polygons using non-maximum suppression.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf: GeoDataFrame with polygons</span>
<span class="sd">        **kwargs: Optional parameters:</span>
<span class="sd">            nms_iou_threshold: IoU threshold for filtering</span>

<span class="sd">    Returns:</span>
<span class="sd">        Filtered GeoDataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="c1"># Get parameters from kwargs or use instance defaults</span>
    <span class="n">iou_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nms_iou_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span><span class="p">)</span>

    <span class="c1"># Sort by confidence</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;confidence&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Fix any invalid geometries</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_valid</span> <span class="k">else</span> <span class="n">geom</span>
    <span class="p">)</span>

    <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">:</span>
            <span class="c1"># Skip invalid geometries</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Calculate IoU</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">area</span>
                <span class="n">union</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">+</span> <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="n">intersection</span>
                <span class="n">iou</span> <span class="o">=</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">union</span> <span class="k">if</span> <span class="n">union</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">iou</span> <span class="o">&gt;</span> <span class="n">iou_threshold</span><span class="p">:</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Skip on topology exceptions</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">keep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.generate_masks" class="doc doc-heading">
<code class="highlight language-python"><span class="n">generate_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">confidence_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_object_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_object_area</span><span class="o">=</span><span class="n">inf</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.generate_masks" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Save masks with confidence values as a multi-band GeoTIFF.</p>
<p>Objects with area smaller than min_object_area or larger than max_object_area
will be filtered out.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to input raster</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path for output GeoTIFF</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>confidence_threshold</code></td>
        <td></td>
        <td><p>Minimum confidence score (0.0-1.0)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>mask_threshold</code></td>
        <td></td>
        <td><p>Threshold for mask binarization (0.0-1.0)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>min_object_area</code></td>
        <td></td>
        <td><p>Minimum area (in pixels) for an object to be included</p></td>
        <td><code>10</code></td>
      </tr>
      <tr>
        <td><code>max_object_area</code></td>
        <td></td>
        <td><p>Maximum area (in pixels) for an object to be included</p></td>
        <td><code>inf</code></td>
      </tr>
      <tr>
        <td><code>overlap</code></td>
        <td></td>
        <td><p>Overlap between tiles (0.0-1.0)</p></td>
        <td><code>0.25</code></td>
      </tr>
      <tr>
        <td><code>batch_size</code></td>
        <td></td>
        <td><p>Batch size for processing</p></td>
        <td><code>4</code></td>
      </tr>
      <tr>
        <td><code>band_indexes</code></td>
        <td></td>
        <td><p>List of band indexes to use (default: all bands)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>verbose</code></td>
        <td></td>
        <td><p>Whether to print detailed processing information</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>Path to the saved GeoTIFF</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_masks</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">raster_path</span><span class="p">,</span>
    <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">confidence_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_object_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">max_object_area</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
    <span class="n">overlap</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save masks with confidence values as a multi-band GeoTIFF.</span>

<span class="sd">    Objects with area smaller than min_object_area or larger than max_object_area</span>
<span class="sd">    will be filtered out.</span>

<span class="sd">    Args:</span>
<span class="sd">        raster_path: Path to input raster</span>
<span class="sd">        output_path: Path for output GeoTIFF</span>
<span class="sd">        confidence_threshold: Minimum confidence score (0.0-1.0)</span>
<span class="sd">        mask_threshold: Threshold for mask binarization (0.0-1.0)</span>
<span class="sd">        min_object_area: Minimum area (in pixels) for an object to be included</span>
<span class="sd">        max_object_area: Maximum area (in pixels) for an object to be included</span>
<span class="sd">        overlap: Overlap between tiles (0.0-1.0)</span>
<span class="sd">        batch_size: Batch size for processing</span>
<span class="sd">        band_indexes: List of band indexes to use (default: all bands)</span>
<span class="sd">        verbose: Whether to print detailed processing information</span>

<span class="sd">    Returns:</span>
<span class="sd">        Path to the saved GeoTIFF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use provided thresholds or fall back to instance defaults</span>
    <span class="k">if</span> <span class="n">confidence_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
    <span class="k">if</span> <span class="n">mask_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span>

    <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>

    <span class="c1"># Default output path</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_masks_conf.tif&quot;</span>

    <span class="c1"># Process the raster to get individual masks with confidence</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Create dataset with the specified overlap</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
            <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
            <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">band_indexes</span><span class="o">=</span><span class="n">band_indexes</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create output profile</span>
        <span class="n">output_profile</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">output_profile</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Two bands: mask and confidence</span>
            <span class="n">compress</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize mask and confidence arrays</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">conf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># Define custom collate function to handle Shapely objects</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Custom collate function that handles Shapely geometries</span>
<span class="sd">            by keeping them as Python objects rather than trying to collate them.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For tensors and other collatable types</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="c1"># Fall back to list for non-collatable types</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default collate for non-dict types</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

        <span class="c1"># Create dataloader with custom collate function</span>
        <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Process batches</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
            <span class="c1"># Move images to device</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># Tensor of shape [batch_size, 2]</span>

            <span class="c1"># Run inference</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

            <span class="c1"># Process predictions</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="c1"># Filter by confidence threshold</span>
                <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
                <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

                <span class="c1"># Skip if no valid predictions</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Get window coordinates</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="c1"># Process each mask</span>
                <span class="k">for</span> <span class="n">mask_idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
                    <span class="c1"># Convert to binary mask</span>
                    <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

                    <span class="c1"># Check object area - calculate number of pixels in the mask</span>
                    <span class="n">object_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># Skip objects that don&#39;t meet area criteria</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">object_area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span>
                        <span class="ow">or</span> <span class="n">object_area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Filtering out object with area </span><span class="si">{</span><span class="n">object_area</span><span class="si">}</span><span class="s2"> pixels&quot;</span>
                            <span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="n">conf_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">mask_idx</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>  <span class="c1"># Scale to 0-255</span>

                    <span class="c1"># Update the mask and confidence arrays</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">valid_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>
                    <span class="n">valid_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">valid_h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">valid_w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Use maximum for overlapping regions in the mask</span>
                        <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">],</span>
                            <span class="n">binary_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">],</span>
                        <span class="p">)</span>

                        <span class="c1"># For confidence, only update where mask is positive</span>
                        <span class="c1"># and confidence is higher than existing</span>
                        <span class="n">mask_region</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_region</span><span class="p">):</span>
                            <span class="c1"># Only update where mask is positive and new confidence is higher</span>
                            <span class="n">current_conf</span> <span class="o">=</span> <span class="n">conf_array</span><span class="p">[</span>
                                <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span>
                            <span class="p">]</span>

                            <span class="c1"># Where to update confidence (mask positive &amp; higher confidence)</span>
                            <span class="n">update_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">mask_region</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                                    <span class="n">current_conf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_conf</span> <span class="o">&lt;</span> <span class="n">conf_value</span>
                                <span class="p">),</span>
                            <span class="p">)</span>

                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">update_mask</span><span class="p">):</span>
                                <span class="n">conf_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">][</span>
                                    <span class="n">update_mask</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="n">conf_value</span>

        <span class="c1"># Write to GeoTIFF</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">output_profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">conf_array</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Masks with confidence values saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_path</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.initialize_model" class="doc doc-heading">
<code class="highlight language-python"><span class="n">initialize_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.initialize_model" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize a deep learning model for object detection.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model</code></td>
        <td><code>torch.nn.Module</code></td>
        <td><p>A pre-initialized model object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>num_classes</code></td>
        <td><code>int</code></td>
        <td><p>Number of classes for detection.</p></td>
        <td><code>2</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>torch.nn.Module</code></td>
      <td><p>A deep learning model for object detection.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">initialize_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize a deep learning model for object detection.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): A pre-initialized model object.</span>
<span class="sd">        num_classes (int): Number of classes for detection.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.nn.Module: A deep learning model for object detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Initialize Mask R-CNN model with ResNet50 backbone.</span>
        <span class="c1"># Standard image mean and std for pre-trained models</span>
        <span class="n">image_mean</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
        <span class="n">image_std</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>

        <span class="c1"># Create model with explicit normalization parameters</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">maskrcnn_resnet50_fpn</span><span class="p">(</span>
            <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>  <span class="c1"># Background + object</span>
            <span class="n">weights_backbone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="c1"># These parameters ensure consistent normalization</span>
            <span class="n">image_mean</span><span class="o">=</span><span class="n">image_mean</span><span class="p">,</span>
            <span class="n">image_std</span><span class="o">=</span><span class="n">image_std</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.load_weights" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.load_weights" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Load weights from file with error handling for different formats.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to model weights</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">load_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load weights from file with error handling for different formats.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to model weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">model_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model file not found: </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Handle different state dict formats</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;model&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
                <span class="n">state_dict</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s2">&quot;state_dict&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
                <span class="n">state_dict</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;state_dict&quot;</span><span class="p">]</span>

        <span class="c1"># Try to load state dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model loaded successfully&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempting to fix state_dict keys...&quot;</span><span class="p">)</span>

            <span class="c1"># Try to fix state_dict keys (remove module prefix if needed)</span>
            <span class="n">new_state_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;module.&quot;</span><span class="p">):</span>
                    <span class="n">new_state_dict</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">7</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_state_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">new_state_dict</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model loaded successfully after key fixing&quot;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to load model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.mask_to_polygons" class="doc doc-heading">
<code class="highlight language-python"><span class="n">mask_to_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.mask_to_polygons" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Convert binary mask to polygon contours using OpenCV.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mask</code></td>
        <td></td>
        <td><p>Binary mask as numpy array</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Optional parameters:
simplify_tolerance: Tolerance for polygon simplification
mask_threshold: Threshold for mask binarization
min_object_area: Minimum area in pixels to keep an object
max_object_area: Maximum area in pixels to keep an object</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>List of polygons as lists of (x, y) coordinates</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">mask_to_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert binary mask to polygon contours using OpenCV.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask: Binary mask as numpy array</span>
<span class="sd">        **kwargs: Optional parameters:</span>
<span class="sd">            simplify_tolerance: Tolerance for polygon simplification</span>
<span class="sd">            mask_threshold: Threshold for mask binarization</span>
<span class="sd">            min_object_area: Minimum area in pixels to keep an object</span>
<span class="sd">            max_object_area: Maximum area in pixels to keep an object</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of polygons as lists of (x, y) coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get parameters from kwargs or use instance defaults</span>
    <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simplify_tolerance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span><span class="p">)</span>
    <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
    <span class="n">min_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span><span class="p">)</span>
    <span class="n">max_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span><span class="p">)</span>

    <span class="c1"># Ensure binary mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># Optional: apply morphological operations to improve mask quality</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

    <span class="c1"># Find contours</span>
    <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span>

    <span class="c1"># Convert to list of [x, y] coordinates</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
        <span class="c1"># Filter out too small contours</span>
        <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Filter out too large contours</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_object_area</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Simplify contour if it has many points</span>
        <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">simplify_tolerance</span> <span class="o">*</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Convert to list of [x, y] coordinates</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.masks_to_vector" class="doc doc-heading">
<code class="highlight language-python"><span class="n">masks_to_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplify_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.masks_to_vector" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Convert an object mask GeoTIFF to vector polygons and save as GeoJSON.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mask_path</code></td>
        <td></td>
        <td><p>Path to the object masks GeoTIFF</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path to save the output GeoJSON or Parquet file (default: mask_path with .geojson extension)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>simplify_tolerance</code></td>
        <td></td>
        <td><p>Tolerance for polygon simplification (default: self.simplify_tolerance)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>mask_threshold</code></td>
        <td></td>
        <td><p>Threshold for mask binarization (default: self.mask_threshold)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>min_object_area</code></td>
        <td></td>
        <td><p>Minimum area in pixels to keep an object (default: self.min_object_area)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>max_object_area</code></td>
        <td></td>
        <td><p>Minimum area in pixels to keep an object (default: self.max_object_area)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>nms_iou_threshold</code></td>
        <td></td>
        <td><p>IoU threshold for non-maximum suppression (default: self.nms_iou_threshold)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>regularize</code></td>
        <td></td>
        <td><p>Whether to regularize objects to right angles (default: True)</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>angle_threshold</code></td>
        <td></td>
        <td><p>Maximum deviation from 90 degrees for regularization (default: 15)</p></td>
        <td><code>15</code></td>
      </tr>
      <tr>
        <td><code>rectangularity_threshold</code></td>
        <td></td>
        <td><p>Threshold for rectangle simplification (default: 0.7)</p></td>
        <td><code>0.7</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with objects</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">masks_to_vector</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">mask_path</span><span class="p">,</span>
    <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mask_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an object mask GeoTIFF to vector polygons and save as GeoJSON.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask_path: Path to the object masks GeoTIFF</span>
<span class="sd">        output_path: Path to save the output GeoJSON or Parquet file (default: mask_path with .geojson extension)</span>
<span class="sd">        simplify_tolerance: Tolerance for polygon simplification (default: self.simplify_tolerance)</span>
<span class="sd">        mask_threshold: Threshold for mask binarization (default: self.mask_threshold)</span>
<span class="sd">        min_object_area: Minimum area in pixels to keep an object (default: self.min_object_area)</span>
<span class="sd">        max_object_area: Minimum area in pixels to keep an object (default: self.max_object_area)</span>
<span class="sd">        nms_iou_threshold: IoU threshold for non-maximum suppression (default: self.nms_iou_threshold)</span>
<span class="sd">        regularize: Whether to regularize objects to right angles (default: True)</span>
<span class="sd">        angle_threshold: Maximum deviation from 90 degrees for regularization (default: 15)</span>
<span class="sd">        rectangularity_threshold: Threshold for rectangle simplification (default: 0.7)</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use class defaults if parameters not provided</span>
    <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">simplify_tolerance</span>
        <span class="k">if</span> <span class="n">simplify_tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span>
    <span class="p">)</span>
    <span class="n">mask_threshold</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mask_threshold</span> <span class="k">if</span> <span class="n">mask_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span>
    <span class="p">)</span>
    <span class="n">min_object_area</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">min_object_area</span> <span class="k">if</span> <span class="n">min_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span>
    <span class="p">)</span>
    <span class="n">max_object_area</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">max_object_area</span> <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span>
    <span class="p">)</span>
    <span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">nms_iou_threshold</span>
        <span class="k">if</span> <span class="n">nms_iou_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span>
    <span class="p">)</span>

    <span class="c1"># Set default output path if not provided</span>
    <span class="c1"># if output_path is None:</span>
    <span class="c1">#     output_path = os.path.splitext(mask_path)[0] + &quot;.geojson&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting mask to GeoJSON with parameters:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min object area: </span><span class="si">{</span><span class="n">min_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Max object area: </span><span class="si">{</span><span class="n">max_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Simplify tolerance: </span><span class="si">{</span><span class="n">simplify_tolerance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- NMS IoU threshold: </span><span class="si">{</span><span class="n">nms_iou_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Regularize objects: </span><span class="si">{</span><span class="n">regularize</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">regularize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Angle threshold: </span><span class="si">{</span><span class="n">angle_threshold</span><span class="si">}</span><span class="s2">° from 90°&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Rectangularity threshold: </span><span class="si">{</span><span class="n">rectangularity_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

    <span class="c1"># Open the mask raster</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Read the mask data</span>
        <span class="n">mask_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

        <span class="c1"># Print mask statistics</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask dimensions: </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask value range: </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">mask_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare for connected component analysis</span>
        <span class="c1"># Binarize the mask based on threshold</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_data</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">mask_threshold</span> <span class="o">*</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># Apply morphological operations for better results (optional)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

        <span class="c1"># Find connected components</span>
        <span class="n">num_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span>
            <span class="n">binary_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">num_labels</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> potential objects&quot;</span>
        <span class="p">)</span>  <span class="c1"># Subtract 1 for background</span>

        <span class="c1"># Create list to store polygons and confidence values</span>
        <span class="n">all_polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_confidences</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Process each component (skip the first one which is background)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_labels</span><span class="p">)):</span>
            <span class="c1"># Extract this object</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span>

            <span class="c1"># Skip if too small</span>
            <span class="k">if</span> <span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Skip if too large</span>
            <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Create a mask for this object</span>
            <span class="n">object_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Find contours</span>
            <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                <span class="n">object_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
            <span class="p">)</span>

            <span class="c1"># Process each contour</span>
            <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                <span class="c1"># Skip if too few points</span>
                <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Simplify contour if it has many points</span>
                <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">simplify_tolerance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">simplify_tolerance</span> <span class="o">*</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">contour</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Convert to list of (x, y) coordinates</span>
                <span class="n">polygon_points</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Convert pixel coordinates to geographic coordinates</span>
                <span class="n">geo_points</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">polygon_points</span><span class="p">:</span>
                    <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">geo_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                <span class="c1"># Create Shapely polygon</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">and</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely_poly</span><span class="p">)</span>

                            <span class="c1"># Calculate &quot;confidence&quot; as normalized size</span>
                            <span class="c1"># This is a proxy since we don&#39;t have model confidence scores</span>
                            <span class="n">normalized_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">area</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Cap at 1.0</span>
                            <span class="n">all_confidences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalized_size</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating polygon: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_polygons</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid polygons&quot;</span><span class="p">)</span>

        <span class="c1"># Create GeoDataFrame</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_polygons</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">all_polygons</span><span class="p">,</span>
                <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">all_confidences</span><span class="p">,</span>
                <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Object class</span>
            <span class="p">},</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Apply non-maximum suppression to remove overlapping polygons</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_overlapping_polygons</span><span class="p">(</span>
            <span class="n">gdf</span><span class="p">,</span> <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="n">nms_iou_threshold</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object count after NMS filtering: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Apply regularization if requested</span>
        <span class="k">if</span> <span class="n">regularize</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Convert pixel area to geographic units for min_area parameter</span>
            <span class="c1"># Estimate pixel size in geographic units</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span>
                    <span class="mi">0</span>
                <span class="p">]</span>  <span class="c1"># width of a pixel in geographic units</span>
                <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># height of a pixel in geographic units</span>
                <span class="n">avg_pixel_area</span> <span class="o">=</span> <span class="n">pixel_size_x</span> <span class="o">*</span> <span class="n">pixel_size_y</span>

            <span class="c1"># Use 10 pixels as minimum area in geographic units</span>
            <span class="n">min_geo_area</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">avg_pixel_area</span>

            <span class="c1"># Regularize objects</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularize_objects</span><span class="p">(</span>
                <span class="n">gdf</span><span class="p">,</span>
                <span class="n">min_area</span><span class="o">=</span><span class="n">min_geo_area</span><span class="p">,</span>
                <span class="n">angle_threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">,</span>
                <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="n">rectangularity_threshold</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Save to file</span>
        <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.parquet&quot;</span><span class="p">):</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.process_raster" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">filter_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.process_raster" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Process a raster file to extract objects with customizable parameters.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to input raster file</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path to output GeoJSON or Parquet file (optional)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>batch_size</code></td>
        <td></td>
        <td><p>Batch size for processing</p></td>
        <td><code>4</code></td>
      </tr>
      <tr>
        <td><code>filter_edges</code></td>
        <td></td>
        <td><p>Whether to filter out objects at the edges of the image</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>edge_buffer</code></td>
        <td></td>
        <td><p>Size of edge buffer in pixels to filter out objects (if filter_edges=True)</p></td>
        <td><code>20</code></td>
      </tr>
      <tr>
        <td><code>band_indexes</code></td>
        <td></td>
        <td><p>List of band indexes to use (if None, use all bands)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Additional parameters:
confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)
overlap: Overlap between adjacent tiles (0.0-1.0)
chip_size: Size of image chips for processing (height, width)
nms_iou_threshold: IoU threshold for non-maximum suppression (0.0-1.0)
mask_threshold: Threshold for mask binarization (0.0-1.0)
min_object_area: Minimum area in pixels to keep an object
simplify_tolerance: Tolerance for polygon simplification</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with objects</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_raster</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">raster_path</span><span class="p">,</span>
    <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">filter_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">edge_buffer</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">band_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a raster file to extract objects with customizable parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        raster_path: Path to input raster file</span>
<span class="sd">        output_path: Path to output GeoJSON or Parquet file (optional)</span>
<span class="sd">        batch_size: Batch size for processing</span>
<span class="sd">        filter_edges: Whether to filter out objects at the edges of the image</span>
<span class="sd">        edge_buffer: Size of edge buffer in pixels to filter out objects (if filter_edges=True)</span>
<span class="sd">        band_indexes: List of band indexes to use (if None, use all bands)</span>
<span class="sd">        **kwargs: Additional parameters:</span>
<span class="sd">            confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)</span>
<span class="sd">            overlap: Overlap between adjacent tiles (0.0-1.0)</span>
<span class="sd">            chip_size: Size of image chips for processing (height, width)</span>
<span class="sd">            nms_iou_threshold: IoU threshold for non-maximum suppression (0.0-1.0)</span>
<span class="sd">            mask_threshold: Threshold for mask binarization (0.0-1.0)</span>
<span class="sd">            min_object_area: Minimum area in pixels to keep an object</span>
<span class="sd">            simplify_tolerance: Tolerance for polygon simplification</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get parameters from kwargs or use instance defaults</span>
    <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;confidence_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
    <span class="p">)</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>
    <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>
    <span class="n">nms_iou_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nms_iou_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_iou_threshold</span><span class="p">)</span>
    <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
    <span class="n">min_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_object_area</span><span class="p">)</span>
    <span class="n">max_object_area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_object_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_object_area</span><span class="p">)</span>
    <span class="n">simplify_tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simplify_tolerance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify_tolerance</span><span class="p">)</span>

    <span class="c1"># Print parameters being used</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing with parameters:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Confidence threshold: </span><span class="si">{</span><span class="n">confidence_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Tile overlap: </span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Chip size: </span><span class="si">{</span><span class="n">chip_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- NMS IoU threshold: </span><span class="si">{</span><span class="n">nms_iou_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min object area: </span><span class="si">{</span><span class="n">min_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Max object area: </span><span class="si">{</span><span class="n">max_object_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Simplify tolerance: </span><span class="si">{</span><span class="n">simplify_tolerance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Filter edge objects: </span><span class="si">{</span><span class="n">filter_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filter_edges</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Edge buffer size: </span><span class="si">{</span><span class="n">edge_buffer</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>

    <span class="c1"># Create dataset</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
        <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
        <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
        <span class="n">band_indexes</span><span class="o">=</span><span class="n">band_indexes</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">raster_stats</span>

    <span class="c1"># Custom collate function to handle Shapely objects</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom collate function that handles Shapely geometries</span>
<span class="sd">        by keeping them as Python objects rather than trying to collate them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For tensors and other collatable types</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="c1"># Fall back to list for non-collatable types</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default collate for non-dict types</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

    <span class="c1"># Create dataloader with simple indexing and custom collate</span>
    <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
        <span class="n">dataset</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Process batches</span>
    <span class="n">all_polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_scores</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
        <span class="c1"># Move images to device</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># (i, j) coordinates in pixels</span>
        <span class="n">bboxes</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span>
            <span class="s2">&quot;bbox&quot;</span>
        <span class="p">]</span>  <span class="c1"># Geographic bounding boxes - now a list, not a tensor</span>

        <span class="c1"># Run inference</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

        <span class="c1"># Process predictions</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

            <span class="c1"># Skip if no predictions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Filter by confidence threshold</span>
            <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

            <span class="c1"># Skip if no valid predictions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get window coordinates</span>
            <span class="c1"># The coords might be in different formats depending on batch handling</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># If coords is a list of tuples</span>
                <span class="n">coord_item</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="c1"># If coords is a tensor of shape [batch_size, 2]</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Get window size</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">window_item</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected window_size format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected window_size type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s1">&#39;window_size&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Process masks to polygons</span>
            <span class="k">for</span> <span class="n">mask_idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
                <span class="c1"># Get binary mask</span>
                <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Get binary mask</span>

                <span class="c1"># Convert mask to polygon with custom parameters</span>
                <span class="n">contours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_to_polygons</span><span class="p">(</span>
                    <span class="n">binary_mask</span><span class="p">,</span>
                    <span class="n">simplify_tolerance</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span>
                    <span class="n">mask_threshold</span><span class="o">=</span><span class="n">mask_threshold</span><span class="p">,</span>
                    <span class="n">min_object_area</span><span class="o">=</span><span class="n">min_object_area</span><span class="p">,</span>
                    <span class="n">max_object_area</span><span class="o">=</span><span class="n">max_object_area</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Skip if no valid polygons</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">contours</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Transform polygons to geographic coordinates</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

                    <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                        <span class="c1"># Convert polygon to global coordinates</span>
                        <span class="n">global_polygon</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">contour</span><span class="p">:</span>
                            <span class="c1"># Adjust coordinates based on window position</span>
                            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">global_polygon</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                        <span class="c1"># Create Shapely polygon</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">global_polygon</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">global_polygon</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">and</span> <span class="n">shapely_poly</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely_poly</span><span class="p">)</span>
                                    <span class="n">all_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">mask_idx</span><span class="p">]))</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating polygon: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create GeoDataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">all_polygons</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">all_polygons</span><span class="p">,</span>
            <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">all_scores</span><span class="p">,</span>
            <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Object class</span>
        <span class="p">},</span>
        <span class="n">crs</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Remove overlapping polygons with custom threshold</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_overlapping_polygons</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">nms_iou_threshold</span><span class="o">=</span><span class="n">nms_iou_threshold</span><span class="p">)</span>

    <span class="c1"># Filter edge objects if requested</span>
    <span class="k">if</span> <span class="n">filter_edges</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_edge_objects</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">edge_buffer</span><span class="o">=</span><span class="n">edge_buffer</span><span class="p">)</span>

    <span class="c1"># Save to file if requested</span>
    <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.parquet&quot;</span><span class="p">):</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.regularize_objects" class="doc doc-heading">
<code class="highlight language-python"><span class="n">regularize_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.regularize_objects" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Regularize objects to enforce right angles and rectangular shapes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td></td>
        <td><p>GeoDataFrame with objects</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>min_area</code></td>
        <td></td>
        <td><p>Minimum area in square units to keep an object</p></td>
        <td><code>10</code></td>
      </tr>
      <tr>
        <td><code>angle_threshold</code></td>
        <td></td>
        <td><p>Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</p></td>
        <td><code>15</code></td>
      </tr>
      <tr>
        <td><code>orthogonality_threshold</code></td>
        <td></td>
        <td><p>Percentage of angles that must be orthogonal for an object to be regularized</p></td>
        <td><code>0.3</code></td>
      </tr>
      <tr>
        <td><code>rectangularity_threshold</code></td>
        <td></td>
        <td><p>Minimum area ratio to Object's oriented bounding box for rectangular simplification</p></td>
        <td><code>0.7</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with regularized objects</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">regularize_objects</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">min_area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">angle_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">orthogonality_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">rectangularity_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regularize objects to enforce right angles and rectangular shapes.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf: GeoDataFrame with objects</span>
<span class="sd">        min_area: Minimum area in square units to keep an object</span>
<span class="sd">        angle_threshold: Maximum deviation from 90 degrees to consider an angle as orthogonal (degrees)</span>
<span class="sd">        orthogonality_threshold: Percentage of angles that must be orthogonal for an object to be regularized</span>
<span class="sd">        rectangularity_threshold: Minimum area ratio to Object&#39;s oriented bounding box for rectangular simplification</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with regularized objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.affinity</span><span class="w"> </span><span class="kn">import</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">translate</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">box</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_angle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate angle between three points in degrees (0-180)&quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p3</span><span class="p">)</span>

        <span class="n">ba</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span>

        <span class="n">cosine_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ba</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bc</span><span class="p">))</span>
        <span class="c1"># Handle numerical errors that could push cosine outside [-1, 1]</span>
        <span class="n">cosine_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cosine_angle</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosine_angle</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">angle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_orthogonal</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">angle_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if angle is close to 90 degrees&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dominant_direction</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the dominant direction of a polygon using PCA&quot;&quot;&quot;</span>
        <span class="c1"># Extract coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Mean center the coordinates</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">centered_coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">-</span> <span class="n">mean</span>

        <span class="c1"># Calculate covariance matrix and its eigenvalues/eigenvectors</span>
        <span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">centered_coords</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>

        <span class="c1"># Get the index of the largest eigenvalue</span>
        <span class="n">largest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>

        <span class="c1"># Get the corresponding eigenvector (principal axis)</span>
        <span class="n">principal_axis</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">largest_idx</span><span class="p">]</span>

        <span class="c1"># Calculate the angle in degrees</span>
        <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">principal_axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">principal_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">angle_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)</span>

        <span class="c1"># Normalize to range 0-180</span>
        <span class="k">if</span> <span class="n">angle_deg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">angle_deg</span> <span class="o">+=</span> <span class="mi">180</span>

        <span class="k">return</span> <span class="n">angle_deg</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_oriented_envelope</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">angle_deg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an oriented minimum area rectangle for the polygon&quot;&quot;&quot;</span>
        <span class="c1"># Create a rotated rectangle using OpenCV method (more robust than Shapely methods)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>  <span class="c1"># Skip the last point (same as first)</span>

        <span class="c1"># Use OpenCV&#39;s minAreaRect</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">box_points</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>

        <span class="c1"># Convert to shapely polygon</span>
        <span class="n">oriented_box</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">box_points</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">oriented_box</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_rectangularity</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">oriented_box</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the rectangularity (area ratio to its oriented bounding box)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">oriented_box</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">oriented_box</span><span class="o">.</span><span class="n">area</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_orthogonality</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check what percentage of angles in the polygon are orthogonal&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># Triangle or point</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Remove last point (same as first)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">orthogonal_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_angles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_angles</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_angles</span><span class="p">]</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_angles</span><span class="p">]</span>

            <span class="n">angle</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_orthogonal</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
                <span class="n">orthogonal_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">orthogonal_count</span> <span class="o">/</span> <span class="n">total_angles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">simplify_to_rectangle</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simplify a polygon to a rectangle using its oriented bounding box&quot;&quot;&quot;</span>
        <span class="c1"># Get dominant direction</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_dominant_direction</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="c1"># Create oriented envelope</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">create_oriented_envelope</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rect</span>

    <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Objects to regularize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Regularizing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Angle threshold: </span><span class="si">{</span><span class="n">angle_threshold</span><span class="si">}</span><span class="s2">° from 90°&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Min orthogonality: </span><span class="si">{</span><span class="n">orthogonality_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of angles&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;- Min rectangularity: </span><span class="si">{</span><span class="n">rectangularity_threshold</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of bounding box area&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Create a copy to avoid modifying the original</span>
    <span class="n">result_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Track statistics</span>
    <span class="n">total_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
    <span class="n">regularized_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rectangularized_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Process each Object</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)):</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Skip invalid or empty geometries</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Handle MultiPolygons by processing the largest part</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">areas</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">areas</span><span class="p">)]</span>

        <span class="c1"># Filter out tiny Objects</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_area</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Check orthogonality</span>
        <span class="n">orthogonality</span> <span class="o">=</span> <span class="n">check_orthogonality</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>

        <span class="c1"># Create oriented envelope</span>
        <span class="n">oriented_box</span> <span class="o">=</span> <span class="n">create_oriented_envelope</span><span class="p">(</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">calculate_dominant_direction</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check rectangularity</span>
        <span class="n">rectangularity</span> <span class="o">=</span> <span class="n">get_rectangularity</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">oriented_box</span><span class="p">)</span>

        <span class="c1"># Decide how to regularize</span>
        <span class="k">if</span> <span class="n">rectangularity</span> <span class="o">&gt;=</span> <span class="n">rectangularity_threshold</span><span class="p">:</span>
            <span class="c1"># Object is already quite rectangular, simplify to a rectangle</span>
            <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oriented_box</span>
            <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rectangle&quot;</span>
            <span class="n">rectangularized_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">orthogonality</span> <span class="o">&gt;=</span> <span class="n">orthogonality_threshold</span><span class="p">:</span>
            <span class="c1"># Object has many orthogonal angles but isn&#39;t rectangular</span>
            <span class="c1"># Could implement more sophisticated regularization here</span>
            <span class="c1"># For now, we&#39;ll still use the oriented rectangle</span>
            <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oriented_box</span>
            <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;orthogonal&quot;</span>
            <span class="n">regularized_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Object doesn&#39;t have clear orthogonal structure</span>
            <span class="c1"># Keep original but flag as unmodified</span>
            <span class="n">result_gdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;regularized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;original&quot;</span>

    <span class="c1"># Report statistics</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Regularization completed:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Total objects: </span><span class="si">{</span><span class="n">total_objects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;- Rectangular objects: </span><span class="si">{</span><span class="n">rectangularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">rectangularized_count</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;- Other regularized objects: </span><span class="si">{</span><span class="n">regularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">regularized_count</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;- Unmodified objects: </span><span class="si">{</span><span class="n">total_objects</span><span class="o">-</span><span class="n">rectangularized_count</span><span class="o">-</span><span class="n">regularized_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="p">(</span><span class="n">total_objects</span><span class="o">-</span><span class="n">rectangularized_count</span><span class="o">-</span><span class="n">regularized_count</span><span class="p">)</span><span class="o">/</span><span class="n">total_objects</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.save_masks_as_geotiff" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_masks_as_geotiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.save_masks_as_geotiff" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Process a raster file to extract object masks and save as GeoTIFF.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to input raster file</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path to output GeoTIFF file (optional, default: input_masks.tif)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>batch_size</code></td>
        <td></td>
        <td><p>Batch size for processing</p></td>
        <td><code>4</code></td>
      </tr>
      <tr>
        <td><code>verbose</code></td>
        <td></td>
        <td><p>Whether to print detailed processing information</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Additional parameters:
confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)
chip_size: Size of image chips for processing (height, width)
mask_threshold: Threshold for mask binarization (0.0-1.0)</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>Path to the saved GeoTIFF file</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_masks_as_geotiff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a raster file to extract object masks and save as GeoTIFF.</span>

<span class="sd">    Args:</span>
<span class="sd">        raster_path: Path to input raster file</span>
<span class="sd">        output_path: Path to output GeoTIFF file (optional, default: input_masks.tif)</span>
<span class="sd">        batch_size: Batch size for processing</span>
<span class="sd">        verbose: Whether to print detailed processing information</span>
<span class="sd">        **kwargs: Additional parameters:</span>
<span class="sd">            confidence_threshold: Minimum confidence score to keep a detection (0.0-1.0)</span>
<span class="sd">            chip_size: Size of image chips for processing (height, width)</span>
<span class="sd">            mask_threshold: Threshold for mask binarization (0.0-1.0)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Path to the saved GeoTIFF file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get parameters from kwargs or use instance defaults</span>
    <span class="n">confidence_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;confidence_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_threshold</span>
    <span class="p">)</span>
    <span class="n">chip_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chip_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_size</span><span class="p">)</span>
    <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mask_threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>

    <span class="c1"># Set default output path if not provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_masks.tif&quot;</span>

    <span class="c1"># Print parameters being used</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing masks with parameters:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Confidence threshold: </span><span class="si">{</span><span class="n">confidence_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Chip size: </span><span class="si">{</span><span class="n">chip_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Mask threshold: </span><span class="si">{</span><span class="n">mask_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create dataset</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span>
        <span class="n">raster_path</span><span class="o">=</span><span class="n">raster_path</span><span class="p">,</span>
        <span class="n">chip_size</span><span class="o">=</span><span class="n">chip_size</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Store a flag to avoid repetitive messages</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">raster_stats</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">raster_stats</span>
    <span class="n">seen_warnings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;bands&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;resize&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># Dictionary to track resize warnings by shape</span>
    <span class="p">}</span>

    <span class="c1"># Open original raster to get metadata</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Create output binary mask raster with same dimensions as input</span>
        <span class="n">output_profile</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">output_profile</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Single band for object mask</span>
            <span class="n">compress</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create output mask raster</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">output_profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="c1"># Initialize mask with zeros</span>
            <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Custom collate function to handle Shapely objects</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">custom_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Custom collate function for DataLoader&quot;&quot;&quot;</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
                            <span class="c1"># Don&#39;t collate shapely objects, keep as list</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># For tensors and other collatable types</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span>
                                        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                                <span class="c1"># Fall back to list for non-collatable types</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Default collate for non-dict types</span>
                    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_utils</span><span class="o">.</span><span class="n">collate</span><span class="o">.</span><span class="n">default_collate</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

            <span class="c1"># Create dataloader</span>
            <span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
                <span class="n">dataset</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">collate_fn</span><span class="o">=</span><span class="n">custom_collate</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Process batches</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing raster with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">):</span>
                <span class="c1"># Move images to device</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>  <span class="c1"># (i, j) coordinates in pixels</span>

                <span class="c1"># Run inference</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

                <span class="c1"># Process predictions</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                    <span class="n">masks</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                    <span class="n">scores</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                    <span class="c1"># Skip if no predictions</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Filter by confidence threshold</span>
                    <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&gt;=</span> <span class="n">confidence_threshold</span>
                    <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
                    <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

                    <span class="c1"># Skip if no valid predictions</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Get window coordinates</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">coord_item</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coord_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coord_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected coords type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># Get window size</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">window_item</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="n">window_item</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_item</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                            <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">window_item</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Unexpected window_size format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">window_item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Unexpected window_size type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s1">&#39;window_size&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># Combine all masks for this window</span>
                    <span class="n">combined_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">window_height</span><span class="p">,</span> <span class="n">window_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                    <span class="p">)</span>

                    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
                        <span class="c1"># Get the binary mask</span>
                        <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mask_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

                        <span class="c1"># Handle size mismatch - resize binary_mask if needed</span>
                        <span class="n">mask_h</span><span class="p">,</span> <span class="n">mask_w</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span>
                        <span class="k">if</span> <span class="n">mask_h</span> <span class="o">!=</span> <span class="n">window_height</span> <span class="ow">or</span> <span class="n">mask_w</span> <span class="o">!=</span> <span class="n">window_width</span><span class="p">:</span>
                            <span class="n">resize_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">mask_h</span><span class="p">,</span><span class="w"> </span><span class="n">mask_w</span><span class="p">)</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="p">(</span><span class="n">window_height</span><span class="p">,</span><span class="w"> </span><span class="n">window_width</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="k">if</span> <span class="n">resize_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_warnings</span><span class="p">[</span><span class="s2">&quot;resize&quot;</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span>
                                        <span class="sa">f</span><span class="s2">&quot;Resizing mask from </span><span class="si">{</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="p">(</span><span class="n">window_height</span><span class="p">,</span><span class="w"> </span><span class="n">window_width</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_warnings</span><span class="p">[</span>
                                        <span class="s2">&quot;resize&quot;</span>
                                    <span class="p">]:</span>  <span class="c1"># If this is the first resize warning</span>
                                        <span class="nb">print</span><span class="p">(</span>
                                            <span class="sa">f</span><span class="s2">&quot;Resizing masks at image edges (set verbose=True for details)&quot;</span>
                                        <span class="p">)</span>
                                <span class="n">seen_warnings</span><span class="p">[</span><span class="s2">&quot;resize&quot;</span><span class="p">][</span><span class="n">resize_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                            <span class="c1"># Crop or pad the binary mask to match window size</span>
                            <span class="n">resized_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">window_height</span><span class="p">,</span> <span class="n">window_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
                            <span class="p">)</span>
                            <span class="n">copy_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mask_h</span><span class="p">,</span> <span class="n">window_height</span><span class="p">)</span>
                            <span class="n">copy_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mask_w</span><span class="p">,</span> <span class="n">window_width</span><span class="p">)</span>
                            <span class="n">resized_mask</span><span class="p">[:</span><span class="n">copy_h</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="p">[</span>
                                <span class="p">:</span><span class="n">copy_h</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_w</span>
                            <span class="p">]</span>
                            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">resized_mask</span>

                        <span class="c1"># Update combined mask (taking maximum where masks overlap)</span>
                        <span class="n">combined_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">combined_mask</span><span class="p">,</span> <span class="n">binary_mask</span><span class="p">)</span>

                    <span class="c1"># Write combined mask to output array</span>
                    <span class="c1"># Handle edge cases where window might be smaller than chip size</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">combined_mask</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">valid_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>
                    <span class="n">valid_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">valid_h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">valid_w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="n">mask_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">valid_h</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">valid_w</span><span class="p">],</span>
                            <span class="n">combined_mask</span><span class="p">[:</span><span class="n">valid_h</span><span class="p">,</span> <span class="p">:</span><span class="n">valid_w</span><span class="p">],</span>
                        <span class="p">)</span>

            <span class="c1"># Write the final mask to the output file</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object masks saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_path</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.vectorize_masks" class="doc doc-heading">
<code class="highlight language-python"><span class="n">vectorize_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masks_path</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">confidence_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">min_object_area</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>


<a href="#geoai.extract.ObjectDetector.vectorize_masks" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Convert masks with confidence to vector polygons.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>masks_path</code></td>
        <td></td>
        <td><p>Path to masks GeoTIFF with confidence band.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path for output GeoJSON.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>confidence_threshold</code></td>
        <td></td>
        <td><p>Minimum confidence score (0.0-1.0). Default: 0.5</p></td>
        <td><code>0.5</code></td>
      </tr>
      <tr>
        <td><code>min_object_area</code></td>
        <td></td>
        <td><p>Minimum area in pixels to keep an object. Default: 100</p></td>
        <td><code>100</code></td>
      </tr>
      <tr>
        <td><code>max_object_area</code></td>
        <td></td>
        <td><p>Maximum area in pixels to keep an object. Default: None</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Additional parameters</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>GeoDataFrame with car detections and confidence values</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vectorize_masks</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">masks_path</span><span class="p">,</span>
    <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">confidence_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">min_object_area</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">max_object_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert masks with confidence to vector polygons.</span>

<span class="sd">    Args:</span>
<span class="sd">        masks_path: Path to masks GeoTIFF with confidence band.</span>
<span class="sd">        output_path: Path for output GeoJSON.</span>
<span class="sd">        confidence_threshold: Minimum confidence score (0.0-1.0). Default: 0.5</span>
<span class="sd">        min_object_area: Minimum area in pixels to keep an object. Default: 100</span>
<span class="sd">        max_object_area: Maximum area in pixels to keep an object. Default: None</span>
<span class="sd">        **kwargs: Additional parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame with car detections and confidence values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing masks from: </span><span class="si">{</span><span class="n">masks_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">masks_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Read mask and confidence bands</span>
        <span class="n">mask_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">conf_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

        <span class="c1"># Convert to binary mask</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask_data</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Find connected components</span>
        <span class="n">labeled_mask</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">num_features</span><span class="si">}</span><span class="s2"> connected components&quot;</span><span class="p">)</span>

        <span class="c1"># Process each component</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">confidences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add progress bar</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing components&quot;</span><span class="p">):</span>
            <span class="c1"># Create mask for this component</span>
            <span class="n">component_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labeled_mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Get confidence value (mean of non-zero values in this region)</span>
            <span class="n">conf_region</span> <span class="o">=</span> <span class="n">conf_data</span><span class="p">[</span><span class="n">component_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conf_region</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">confidence</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">conf_region</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
                <span class="p">)</span>  <span class="c1"># Convert back to 0-1 range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">confidence</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Skip if confidence is below threshold</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="o">&lt;</span> <span class="n">confidence_threshold</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Find contours</span>
            <span class="n">contours</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span>
                <span class="n">component_mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                <span class="c1"># Filter by size</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">area</span> <span class="o">&lt;</span> <span class="n">min_object_area</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">max_object_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">max_object_area</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="c1"># Get minimum area rectangle</span>
                <span class="n">rect</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
                <span class="n">box_points</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>

                <span class="c1"># Convert to geographic coordinates</span>
                <span class="n">geo_points</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">box_points</span><span class="p">:</span>
                    <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">geo_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">))</span>

                <span class="c1"># Create polygon</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geo_points</span><span class="p">)</span>

                <span class="c1"># Add to lists</span>
                <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="n">confidences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confidence</span><span class="p">)</span>
                <span class="n">pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

        <span class="c1"># Create GeoDataFrame</span>
        <span class="k">if</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">polygons</span><span class="p">,</span>
                    <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">confidences</span><span class="p">,</span>
                    <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">),</span>
                    <span class="s2">&quot;pixels&quot;</span><span class="p">:</span> <span class="n">pixels</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Save to file if requested</span>
            <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects with confidence to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">gdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid polygons found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ObjectDetector.visualize_results" class="doc doc-heading">
<code class="highlight language-python"><span class="n">visualize_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">gdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span></code>


<a href="#geoai.extract.ObjectDetector.visualize_results" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Visualize object detection results with proper coordinate transformation.</p>
<p>This function displays objects on top of the raster image,
ensuring proper alignment between the GeoDataFrame polygons and the image.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>raster_path</code></td>
        <td></td>
        <td><p>Path to input raster</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gdf</code></td>
        <td></td>
        <td><p>GeoDataFrame with object polygons (optional)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td></td>
        <td><p>Path to save visualization (optional)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>figsize</code></td>
        <td></td>
        <td><p>Figure size (width, height) in inches</p></td>
        <td><code>(12, 12)</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool</code></td>
      <td><p>True if visualization was successful</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">visualize_results</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">raster_path</span><span class="p">,</span> <span class="n">gdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize object detection results with proper coordinate transformation.</span>

<span class="sd">    This function displays objects on top of the raster image,</span>
<span class="sd">    ensuring proper alignment between the GeoDataFrame polygons and the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        raster_path: Path to input raster</span>
<span class="sd">        gdf: GeoDataFrame with object polygons (optional)</span>
<span class="sd">        output_path: Path to save visualization (optional)</span>
<span class="sd">        figsize: Figure size (width, height) in inches</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if visualization was successful</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if raster file exists</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">raster_path</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Raster file &#39;</span><span class="si">{</span><span class="n">raster_path</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Process raster if GeoDataFrame not provided</span>
    <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_raster</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gdf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No objects to visualize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check if confidence column exists in the GeoDataFrame</span>
    <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;confidence&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Try to access a confidence value to confirm it works</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Try getitem access</span>
                <span class="n">conf_val</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Using confidence values (range: </span><span class="si">{</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confidence column exists but couldn&#39;t access values: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No confidence column found in GeoDataFrame&quot;</span><span class="p">)</span>
        <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Read raster for visualization</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Read the entire image or a subset if it&#39;s very large</span>
        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">2000</span> <span class="ow">or</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
            <span class="c1"># Calculate scale factor to reduce size</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2000</span> <span class="o">/</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">2000</span> <span class="o">/</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">count</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># Read and resample</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">out_shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">resampling</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">enums</span><span class="o">.</span><span class="n">Resampling</span><span class="o">.</span><span class="n">bilinear</span>
            <span class="p">)</span>

            <span class="c1"># Create a scaled transform for the resampled image</span>
            <span class="c1"># Calculate scaling factors</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">out_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">out_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get the original transform</span>
            <span class="n">orig_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

            <span class="c1"># Create a scaled transform</span>
            <span class="n">scaled_transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">d</span><span class="p">,</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">,</span>
                <span class="n">orig_transform</span><span class="o">.</span><span class="n">f</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">scaled_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>

        <span class="c1"># Convert to RGB for display</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Normalize image for display</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># CHW to HWC</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Likely 0-255 range</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get image bounds</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>

    <span class="c1"># Create figure with appropriate aspect ratio</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># width / height</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">aspect_ratio</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

    <span class="c1"># Display image</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="c1"># Make sure the GeoDataFrame has the same CRS as the raster</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">crs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reprojecting GeoDataFrame from </span><span class="si">{</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Set up colors for confidence visualization</span>
    <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.cm</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cm</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Normalize</span>

            <span class="c1"># Get min/max confidence values</span>
            <span class="n">min_conf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">max_conf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># Set up normalization and colormap</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">min_conf</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_conf</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">viridis</span>

            <span class="c1"># Create scalar mappable for colorbar</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
            <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

            <span class="c1"># Add colorbar</span>
            <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                <span class="n">sm</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span>
            <span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Confidence Score&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting up confidence visualization: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">has_confidence</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Function to convert coordinates</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geo_to_pixel</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert geometry to pixel coordinates using the provided transform.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
            <span class="c1"># Get exterior coordinates</span>
            <span class="n">exterior_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

            <span class="c1"># Convert to pixel coordinates</span>
            <span class="n">pixel_coords</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">exterior_coords</span><span class="p">]</span>

            <span class="c1"># Split into x and y lists</span>
            <span class="n">pixel_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>
            <span class="n">pixel_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported geometry type: </span><span class="si">{</span><span class="n">geometry</span><span class="o">.</span><span class="n">geom_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Plot each object</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Convert polygon to pixel coordinates</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">geo_to_pixel</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">scaled_transform</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
                <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span> <span class="o">=</span> <span class="n">coords</span>

                <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Get confidence value using different methods</span>
                        <span class="c1"># Method 1: Try direct attribute access</span>
                        <span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">confidence</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>

                        <span class="c1"># Method 2: Try dictionary-style access</span>
                        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="c1"># Method 3: Try accessing by index from the GeoDataFrame</span>
                        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">confidence</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">confidence</span><span class="p">))</span>
                            <span class="c1"># Fill polygon with semi-transparent color</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                            <span class="c1"># Draw border</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                <span class="n">pixel_x</span><span class="p">,</span>
                                <span class="n">pixel_y</span><span class="p">,</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Fall back to red if confidence value couldn&#39;t be accessed</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Error using confidence value for polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No confidence data, just plot outlines in red</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error plotting polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Remove axes</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;objects (Found: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Save if requested</span>
    <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Visualization saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Create a simpler visualization focused just on a subset of objects</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="c1"># Choose a subset of the image to show</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Get centroid of first object</span>
            <span class="n">sample_geom</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">sample_geom</span><span class="o">.</span><span class="n">centroid</span>

            <span class="c1"># Convert to pixel coordinates</span>
            <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

            <span class="c1"># Define a window around this object</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># pixels</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
            <span class="p">)</span>

            <span class="c1"># Read this window</span>
            <span class="n">sample_image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

            <span class="c1"># Convert to RGB for display</span>
            <span class="k">if</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Normalize image for display</span>
            <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># CHW to HWC</span>
            <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sample_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># Likely 0-255 range</span>
                <span class="n">sample_image</span> <span class="o">=</span> <span class="n">sample_image</span> <span class="o">/</span> <span class="mf">255.0</span>

            <span class="n">sample_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Display sample image</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">sample_image</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Get the correct transform for this window</span>
            <span class="n">window_transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">window_transform</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

            <span class="c1"># Calculate bounds of the window</span>
            <span class="n">window_bounds</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">window_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">window_bounds</span><span class="p">)</span>

            <span class="c1"># Filter objects that intersect with this window</span>
            <span class="n">visible_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">window_box</span><span class="p">)]</span>

            <span class="c1"># Set up colors for sample view if confidence data exists</span>
            <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Reuse the same normalization and colormap from main view</span>
                    <span class="n">sample_sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
                    <span class="n">sample_sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

                    <span class="c1"># Add colorbar to sample view</span>
                    <span class="n">sample_cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                        <span class="n">sample_sm</span><span class="p">,</span>
                        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                        <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span>
                        <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                        <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">sample_cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Confidence Score&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting up sample confidence visualization: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Plot objects in sample view</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">visible_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Get window-relative pixel coordinates</span>
                    <span class="n">geom</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span>

                    <span class="c1"># Skip empty geometries</span>
                    <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Get exterior coordinates</span>
                    <span class="n">exterior_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

                    <span class="c1"># Convert to pixel coordinates relative to window origin</span>
                    <span class="n">pixel_coords</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">exterior_coords</span><span class="p">:</span>
                        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># Convert to image pixels</span>
                        <span class="c1"># Make coordinates relative to window</span>
                        <span class="n">px</span> <span class="o">=</span> <span class="n">px</span> <span class="o">-</span> <span class="n">window</span><span class="o">.</span><span class="n">col_off</span>
                        <span class="n">py</span> <span class="o">=</span> <span class="n">py</span> <span class="o">-</span> <span class="n">window</span><span class="o">.</span><span class="n">row_off</span>
                        <span class="n">pixel_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span>

                    <span class="c1"># Extract x and y coordinates</span>
                    <span class="n">pixel_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>
                    <span class="n">pixel_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">pixel_coords</span><span class="p">]</span>

                    <span class="c1"># Use confidence colors if available</span>
                    <span class="k">if</span> <span class="n">has_confidence</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># Try different methods to access confidence</span>
                            <span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">confidence</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>

                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">visible_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="k">pass</span>

                            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">confidence</span><span class="p">))</span>
                                <span class="c1"># Fill polygon with semi-transparent color</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                                <span class="c1"># Draw border</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                    <span class="n">pixel_x</span><span class="p">,</span>
                                    <span class="n">pixel_y</span><span class="p">,</span>
                                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                    <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                    <span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span>
                                <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Error using confidence in sample view for polygon </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pixel_x</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error plotting polygon in sample view: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Set title</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample Area - objects (Showing: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">visible_gdf</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Remove axes</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">output_path</span><span class="p">:</span>
                <span class="n">sample_output</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_sample&quot;</span>
                    <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">sample_output</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample visualization saved to </span><span class="si">{</span><span class="n">sample_output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.ParkingSplotDetector" class="doc doc-heading">
        <code>
ParkingSplotDetector            (<a class="autorefs autorefs-internal" title="geoai.extract.ObjectDetector" href="#geoai.extract.ObjectDetector">ObjectDetector</a>)
        </code>



<a href="#geoai.extract.ParkingSplotDetector" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Car detection using a pre-trained Mask R-CNN model.</p>
<p>This class extends the <code>ObjectDetector</code> class with additional methods for car detection.</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ParkingSplotDetector</span><span class="p">(</span><span class="n">ObjectDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Car detection using a pre-trained Mask R-CNN model.</span>

<span class="sd">    This class extends the `ObjectDetector` class with additional methods for car detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;parking_spot_detection.pth&quot;</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">            model: Custom model to use for inference.</span>
<span class="sd">            num_classes: Number of classes for the model. Default: 3</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span>
            <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ParkingSplotDetector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s1">&#39;parking_spot_detection.pth&#39;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.ParkingSplotDetector.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>&#39;parking_spot_detection.pth&#39;</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Repo ID for loading models from the Hub.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Custom model to use for inference.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>num_classes</code></td>
        <td></td>
        <td><p>Number of classes for the model. Default: 3</p></td>
        <td><code>3</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;parking_spot_detection.pth&quot;</span><span class="p">,</span>
    <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">        model: Custom model to use for inference.</span>
<span class="sd">        num_classes: Number of classes for the model. Default: 3</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.ShipDetector" class="doc doc-heading">
        <code>
ShipDetector            (<a class="autorefs autorefs-internal" title="geoai.extract.ObjectDetector" href="#geoai.extract.ObjectDetector">ObjectDetector</a>)
        </code>



<a href="#geoai.extract.ShipDetector" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Ship detection using a pre-trained Mask R-CNN model.</p>
<p>This class extends the
<code>ObjectDetector</code> class with additional methods for ship detection."</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ShipDetector</span><span class="p">(</span><span class="n">ObjectDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ship detection using a pre-trained Mask R-CNN model.</span>

<span class="sd">    This class extends the</span>
<span class="sd">    `ObjectDetector` class with additional methods for ship detection.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;ship_detection.pth&quot;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">            model: Custom model to use for inference.</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.ShipDetector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s1">&#39;ship_detection.pth&#39;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.ShipDetector.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>&#39;ship_detection.pth&#39;</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Repo ID for loading models from the Hub.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Custom model to use for inference.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;ship_detection.pth&quot;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">        model: Custom model to use for inference.</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="geoai.extract.SolarPanelDetector" class="doc doc-heading">
        <code>
SolarPanelDetector            (<a class="autorefs autorefs-internal" title="geoai.extract.ObjectDetector" href="#geoai.extract.ObjectDetector">ObjectDetector</a>)
        </code>



<a href="#geoai.extract.SolarPanelDetector" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Solar panel detection using a pre-trained Mask R-CNN model.</p>
<p>This class extends the
<code>ObjectDetector</code> class with additional methods for solar panel detection."</p>

        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SolarPanelDetector</span><span class="p">(</span><span class="n">ObjectDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solar panel detection using a pre-trained Mask R-CNN model.</span>

<span class="sd">    This class extends the</span>
<span class="sd">    `ObjectDetector` class with additional methods for solar panel detection.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;solar_panel_detection.pth&quot;</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_path: Path to the .pth model file.</span>
<span class="sd">            repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">            model: Custom model to use for inference.</span>
<span class="sd">            device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="geoai.extract.SolarPanelDetector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="s1">&#39;solar_panel_detection.pth&#39;</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#geoai.extract.SolarPanelDetector.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Initialize the object extractor.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>model_path</code></td>
        <td></td>
        <td><p>Path to the .pth model file.</p></td>
        <td><code>&#39;solar_panel_detection.pth&#39;</code></td>
      </tr>
      <tr>
        <td><code>repo_id</code></td>
        <td></td>
        <td><p>Repo ID for loading models from the Hub.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>model</code></td>
        <td></td>
        <td><p>Custom model to use for inference.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>device</code></td>
        <td></td>
        <td><p>Device to use for inference ('cuda:0', 'cpu', etc.).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>geoai/extract.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">model_path</span><span class="o">=</span><span class="s2">&quot;solar_panel_detection.pth&quot;</span><span class="p">,</span>
    <span class="n">repo_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the object extractor.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_path: Path to the .pth model file.</span>
<span class="sd">        repo_id: Repo ID for loading models from the Hub.</span>
<span class="sd">        model: Custom model to use for inference.</span>
<span class="sd">        device: Device to use for inference (&#39;cuda:0&#39;, &#39;cpu&#39;, etc.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  </div>

    </div>

  </div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="March 2, 2025 15:55:47"><span class="timeago" datetime="2025-03-02T15:55:47+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="March 2, 2025 15:55:47">2025-03-02</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="March 2, 2025 15:55:47"><span class="timeago" datetime="2025-03-02T15:55:47+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="March 2, 2025 15:55:47">2025-03-02</span>
  </span>

    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 - 2025 Qiusheng Wu
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.tracking", "navigation.top", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../js/timeago.min.js"></script>
      
        <script src="../js/timeago_mkdocs_material.js"></script>
      
    
  </body>
</html>